declare type Int = number;
declare type Float = number;
declare type Bool = boolean;

/* tslint:disable */// Generated by Haxe TypeScript Declaration Generator :)

declare type DisplaySettingsProps = {
	displayMode: number;
	pixelPerfect: boolean;
	vsync: boolean;
	windowHeight: number;
	windowWidth: number;
}

declare type GraphicsSettingsProps = {
	colorBlindConfig: string;
	damageHudPosition: string;
	dustVfx: boolean;
	hitVfx: boolean;
	hitstopShake: boolean;
	hudNumberShake: boolean;
	hudReactionShake: boolean;
	launchScreen: string;
	lights: boolean;
	parryDarkenVfx: boolean;
	pingDisplay: boolean;
	playerOutlines: string;
	screenFilter: string;
	screenShake: boolean;
	shadows: boolean;
	stageBackgrounds: boolean;
}

declare type AssistAnimationStatsProps = {
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	autoRotate: boolean;
	bodyStatus: number;
	bodyStatusStrength: number;
	chargeFramesMax: number;
	chargeFramesTotal: number;
	endType: number;
	grabLimit: number;
	gravityMultiplier: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	immovable: boolean;
	landAnimation: string;
	landType: number;
	leaveGroundCancel: boolean;
	metadata: any;
	name: string;
	nextAnimation: string;
	nextState: number;
	pause: boolean;
	resetId: boolean;
	resetRotation: boolean;
	rotationSpeed: number;
	shadows: boolean;
	slideOff: boolean;
	solid: boolean;
	staleDecay: boolean;
	terminalVelocity: number;
	xSpeedConservation: number;
	ySpeedConservation: number;
}

declare type AssistStatsProps = {
	aerialFootPosition: number;
	aerialFriction: number;
	aerialHeadPosition: number;
	aerialHipWidth: number;
	aerialHipXOffset: number;
	aerialHipYOffset: number;
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	assistBgBeforeTrail: boolean;
	assistChargeValue: number;
	attackRatio: number;
	baseScaleX: number;
	baseScaleY: number;
	cameraBoxHeight: number;
	cameraBoxOffsetX: number;
	cameraBoxOffsetY: number;
	cameraBoxWidth: number;
	damageRatio: number;
	deathBoundsDestroy: boolean;
	floorFootPosition: number;
	floorHeadPosition: number;
	floorHipWidth: number;
	floorHipXOffset: number;
	floorHipYOffset: number;
	friction: number;
	ghost: boolean;
	gravity: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	immovable: boolean;
	initialState: number;
	maxGravity: number;
	metadata: any;
	solid: boolean;
	spriteContent: string;
	stateTransitionMapOverrides: any;
	terminalVelocity: number;
	weight: number;
}

declare type CharacterAnimationStatsProps = {
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	allowFastFall: boolean;
	allowJump: boolean;
	allowMovement: boolean;
	allowTurn: boolean;
	allowTurnOnFirstFrame: boolean;
	autoRotate: boolean;
	autocancel: boolean;
	bodyStatus: number;
	bodyStatusShaderColor: number;
	bodyStatusStrength: number;
	chargeFramesMax: number;
	chargeFramesTotal: number;
	chargeGlow: boolean;
	chargeShake: boolean;
	doubleJumpCancel: boolean;
	endType: number;
	grabLedgeBehind: boolean;
	grabLimit: number;
	gravityMultiplier: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	immovable: boolean;
	landAnimation: string;
	landType: number;
	leaveGroundAnimation: string;
	leaveGroundCancel: boolean;
	leaveGroundType: number;
	metadata: any;
	name: string;
	nextAnimation: string;
	nextState: number;
	pause: boolean;
	resetId: boolean;
	resetRotation: boolean;
	rotationSpeed: number;
	shadows: boolean;
	singleUse: boolean;
	slideOff: boolean;
	solid: boolean;
	staleDecay: boolean;
	terminalVelocity: number;
	xSpeedConservation: number;
	ySpeedConservation: number;
}

declare type CharacterStatsProps = {
	aerialFootPosition: number;
	aerialFriction: number;
	aerialHeadPosition: number;
	aerialHipWidth: number;
	aerialHipXOffset: number;
	aerialHipYOffset: number;
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	airdashAccelMultiplier: number;
	airdashCameraShakeIntensity: number;
	airdashCancelSpeedConservation: number;
	airdashDirections: number;
	airdashEffectOffsetX: number;
	airdashEffectOffsetY: number;
	airdashEffectRadius: number;
	airdashEndlagLength: number;
	airdashEndlagSpeed: number;
	airdashFullspeedLength: number;
	airdashInitialSpeed: number;
	airdashLimit: number;
	airdashSpeedCap: number;
	airdashStartupLength: number;
	airdashTrailEffect: string;
	attackRatio: number;
	attackVoiceIds: string[];
	attackVoiceSilenceRate: number;
	baseScaleX: number;
	baseScaleY: number;
	buryAnimation: string;
	buryFrame: number;
	buryOffsetY: number;
	cameraBoxHeight: number;
	cameraBoxOffsetX: number;
	cameraBoxOffsetY: number;
	cameraBoxWidth: number;
	crawlSpeed: number;
	damageRatio: number;
	dashSpeed: number;
	deathBoundsDestroy: boolean;
	dodgeRollSpeed: number;
	dodgeRollSpeedLength: number;
	dodgeRollSpeedStartFrame: number;
	doubleJumpSpeeds: number[];
	fastFallSpeed: number;
	floatDuration: number;
	floorFootPosition: number;
	floorHeadPosition: number;
	floorHipWidth: number;
	floorHipXOffset: number;
	floorHipYOffset: number;
	friction: number;
	getupRollSpeed: number;
	getupRollSpeedLength: number;
	getupRollSpeedStartFrame: number;
	ghost: boolean;
	grabAirType: number;
	gravity: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	holdToJump: boolean;
	hurtHeavySilenceRate: number;
	hurtHeavyVoiceIds: string[];
	hurtLightSilenceRate: number;
	hurtLightVoiceIds: string[];
	hurtMediumSilenceRate: number;
	hurtMediumVoiceIds: string[];
	immovable: boolean;
	initialGlideSpeed: number;
	initialState: number;
	jumpSpeed: number;
	jumpSpeedBackwardInitialXSpeed: number;
	jumpSpeedForwardInitialXSpeed: number;
	koVoiceIds: string[];
	koVoiceSilenceRate: number;
	ledgeJumpXSpeed: number;
	ledgeJumpYSpeed: number;
	ledgeRollSpeed: number;
	ledgeRollSpeedLength: number;
	ledgeRollSpeedStartFrame: number;
	maxGravity: number;
	menuInfo: any;
	metadata: any;
	runSpeedAcceleration: number;
	runSpeedCap: number;
	runSpeedInitial: number;
	shieldAnimation: string;
	shieldBackHeight: number;
	shieldBackNineSliceContent: string;
	shieldBackWidth: number;
	shieldBackXOffset: number;
	shieldBackYOffset: number;
	shieldCrossupThreshold: number;
	shieldFrontHeight: number;
	shieldFrontNineSliceContent: string;
	shieldFrontWidth: number;
	shieldFrontXOffset: number;
	shieldFrontYOffset: number;
	shieldHeight: number;
	shieldScale: number;
	shieldWidth: number;
	shieldXOffset: number;
	shieldYOffset: number;
	shortHopSpeed: number;
	solid: boolean;
	spriteContent: string;
	stateTransitionMapOverrides: any;
	techRollSpeed: number;
	techRollSpeedLength: number;
	techRollSpeedStartFrame: number;
	terminalVelocity: number;
	walkSpeedAcceleration: number;
	walkSpeedCap: number;
	walkSpeedInitial: number;
	weight: number;
}

declare type HitboxStatsProps = {
	absorbable: boolean;
	angle: number;
	attackId: number;
	attackRatio: number;
	attackStrength: number;
	baseKnockback: number;
	bodyX: number;
	bodyY: number;
	buryTimeBase: number;
	buryTimeScaling: number;
	buryType: number;
	cameraShakeType: number;
	damage: number;
	directionalInfluence: boolean;
	disabled: boolean;
	element: number;
	flinch: boolean;
	forceTumbleFall: boolean;
	hitEffectOverride: string;
	hitSoundOverride: string;
	hitstop: number;
	hitstopMultiplier: number;
	hitstopNudgeMultiplier: number;
	hitstopOffset: number;
	hitstun: number;
	index: number;
	jabResetType: number;
	knockbackCap: number;
	knockbackCapDelay: number;
	knockbackGrowth: number;
	limb: number;
	maxChargeDamageMultiplier: number;
	metadata: any;
	owner: GameObject;
	rawAngle: number;
	rawDamage: number;
	reflectable: boolean;
	reverse: boolean;
	reversibleAngle: boolean;
	selfHitstop: number;
	selfHitstopOffset: number;
	shieldDamageMultiplier: number;
	shieldable: boolean;
	shieldstunMultiplier: number;
	stackKnockback: boolean;
	tumbleType: number;
	weightDependentKnockback: number;
}

declare type ItemAnimationStatsProps = {
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	autoRotate: boolean;
	bodyStatus: number;
	bodyStatusStrength: number;
	chargeFramesMax: number;
	chargeFramesTotal: number;
	endType: number;
	grabLimit: number;
	gravityMultiplier: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	immovable: boolean;
	landAnimation: string;
	landType: number;
	leaveGroundCancel: boolean;
	metadata: any;
	name: string;
	nextAnimation: string;
	nextState: number;
	pause: boolean;
	resetId: boolean;
	resetRotation: boolean;
	rotationSpeed: number;
	shadows: boolean;
	slideOff: boolean;
	solid: boolean;
	staleDecay: boolean;
	terminalVelocity: number;
	xSpeedConservation: number;
	ySpeedConservation: number;
}

declare type ItemStatsProps = {
	aerialFootPosition: number;
	aerialFriction: number;
	aerialHeadPosition: number;
	aerialHipWidth: number;
	aerialHipXOffset: number;
	aerialHipYOffset: number;
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	attackRatio: number;
	baseScaleX: number;
	baseScaleY: number;
	cameraBoxHeight: number;
	cameraBoxOffsetX: number;
	cameraBoxOffsetY: number;
	cameraBoxWidth: number;
	damageRatio: number;
	deathBoundsDestroy: boolean;
	floorFootPosition: number;
	floorHeadPosition: number;
	floorHipWidth: number;
	floorHipXOffset: number;
	floorHipYOffset: number;
	friction: number;
	ghost: boolean;
	gravity: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	immovable: boolean;
	initialState: number;
	maxGravity: number;
	metadata: any;
	solid: boolean;
	spriteContent: string;
	stateTransitionMapOverrides: any;
	terminalVelocity: number;
	weight: number;
}

declare type ProjectileAnimationStatsProps = {
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	autoRotate: boolean;
	bodyStatus: number;
	bodyStatusStrength: number;
	chargeFramesMax: number;
	chargeFramesTotal: number;
	endType: number;
	grabLimit: number;
	gravityMultiplier: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	immovable: boolean;
	landAnimation: string;
	landType: number;
	leaveGroundCancel: boolean;
	metadata: any;
	name: string;
	nextAnimation: string;
	nextState: number;
	pause: boolean;
	resetId: boolean;
	resetRotation: boolean;
	rotationSpeed: number;
	shadows: boolean;
	slideOff: boolean;
	solid: boolean;
	staleDecay: boolean;
	terminalVelocity: number;
	xSpeedConservation: number;
	ySpeedConservation: number;
}

declare type ProjectileStatsProps = {
	aerialFootPosition: number;
	aerialFriction: number;
	aerialHeadPosition: number;
	aerialHipWidth: number;
	aerialHipXOffset: number;
	aerialHipYOffset: number;
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	attackRatio: number;
	baseScaleX: number;
	baseScaleY: number;
	cameraBoxHeight: number;
	cameraBoxOffsetX: number;
	cameraBoxOffsetY: number;
	cameraBoxWidth: number;
	damageRatio: number;
	deathBoundsDestroy: boolean;
	floorFootPosition: number;
	floorHeadPosition: number;
	floorHipWidth: number;
	floorHipXOffset: number;
	floorHipYOffset: number;
	friction: number;
	ghost: boolean;
	gravity: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	immovable: boolean;
	inheritPalette: boolean;
	initialState: number;
	maxGravity: number;
	metadata: any;
	resizable: boolean;
	solid: boolean;
	spriteContent: string;
	stateTransitionMapOverrides: any;
	terminalVelocity: number;
	weight: number;
}

declare type PlaySoundArgs = {
	autoPrefixByResource: boolean;
	autoPrefixResource: Resource;
	category: string;
	channel: string;
	end: number;
	fadeIn: number;
	loop: boolean;
	loopStart: number;
	queue: string;
	start: number;
	volume: number;
}

declare type PlayerBorder = {
	alpha: number;
	color: number;
	radius: number;
	solid: boolean;
}

declare type AnimationStatsProps = {
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	autoRotate: boolean;
	bodyStatus: number;
	bodyStatusStrength: number;
	chargeFramesMax: number;
	chargeFramesTotal: number;
	endType: number;
	grabLimit: number;
	gravityMultiplier: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	immovable: boolean;
	landAnimation: string;
	landType: number;
	leaveGroundCancel: boolean;
	metadata: any;
	name: string;
	nextAnimation: string;
	nextState: number;
	pause: boolean;
	resetId: boolean;
	resetRotation: boolean;
	rotationSpeed: number;
	shadows: boolean;
	slideOff: boolean;
	solid: boolean;
	staleDecay: boolean;
	terminalVelocity: number;
	xSpeedConservation: number;
	ySpeedConservation: number;
}

declare type GameObjectStatsProps = {
	aerialFootPosition: number;
	aerialFriction: number;
	aerialHeadPosition: number;
	aerialHipWidth: number;
	aerialHipXOffset: number;
	aerialHipYOffset: number;
	aerialSpeedAcceleration: number;
	aerialSpeedCap: number;
	attackRatio: number;
	baseScaleX: number;
	baseScaleY: number;
	cameraBoxHeight: number;
	cameraBoxOffsetX: number;
	cameraBoxOffsetY: number;
	cameraBoxWidth: number;
	damageRatio: number;
	deathBoundsDestroy: boolean;
	floorFootPosition: number;
	floorHeadPosition: number;
	floorHipWidth: number;
	floorHipXOffset: number;
	floorHipYOffset: number;
	friction: number;
	ghost: boolean;
	gravity: number;
	groundSpeedAcceleration: number;
	groundSpeedCap: number;
	immovable: boolean;
	initialState: number;
	maxGravity: number;
	metadata: any;
	solid: boolean;
	spriteContent: string;
	stateTransitionMapOverrides: any;
	terminalVelocity: number;
	weight: number;
}

/* tslint:disable */// Generated by Haxe TypeScript Declaration Generator :)

declare class ADisposable {
	constructor();
	dispose(): void;
}

declare class ASerializable extends ADisposable {
	constructor();
}

/**
 * Base class for any API-wrapped object
 */
declare class ApiObject extends ASerializable {
	/**
	 * Generic exports object accessible via the Api's global scope. Arbitrary variables and functions can be attached to it, but note that this object will not be automatically serialized for rollback.
	 */
	exports: any;
	isDisposed(): boolean;
	/**
	 * Allocates a serializable integer
	 * @param	value Initial value of integer
	 * @return Returns the serializable wrapper for the integer
	 */
	makeInt(value: number): ApiVarInt;
	/**
	 * Allocates a serializable float
	 * @param	value Initial value of float
	 * @return Returns the serializable wrapper for the float
	 */
	makeFloat(value: number): ApiVarFloat;
	/**
	 * Allocates a serializable boolean
	 * @param	value Initial value of boolean
	 * @return Returns the serializable wrapper for the float
	 */
	makeBool(value: boolean): ApiVarBool;
	/**
	 * Allocates a serializable string. Maximum limit of serializable strings is currently 4 per object.
	 * @param	value Initial value of string
	 * @return Returns the serializable wrapper for the string
	 */
	makeString(value: string): ApiVarString;
	/**
	 * Allocates a serializable object. Unlike serializable primitives, this only serializes the pointer to the objects you set it to rather than literally serializing the data within the object. When the historical state of your ApiObject is popped, the reference to the object that existed at the time the history was last pushed will be restored. ApiObjects will be serialized by the engine, however for anonymous structures you must manage their internal history yourself.
	 * @param	value Object to store a reference to
	 * @return Returns the serializable wrapper for the object
	 */
	makeObject(value: any): ApiVarObject;
	/**
	 * Allocates an Array of objects references. Note that this data type only serializes the pointer to the objects you set it to rather than literally serializing the data within the object. When the historical state of your ApiVarerenceArray is popped, the reference to the Array that existed at the time the history was last pushed will be restored.
	 * @param	value Object reference array to serialize
	 * @return Returns the serializable wrapper for the object
	 */
	makeArray(value: any[]): ApiVarArray;
	/**
	 * Allocates a rollback-friendly FrameTimer instance that will be automatically destroyed when this object is disposed of.
	 */
	makeFrameTimer(initDuration: number): FrameTimer;
	/**
	 * Allocates a rollback-friendly EaseTimer instance that will be automatically destroyed when this object is disposed of.
	 */
	makeEaseTimer(from: number, to: number, length: number, easeType?: number): EaseTimer;
	/**
	 * Allocates a rollback-friendly Point instance that will be automatically destroyed when this object is disposed of.
	 */
	makePoint(x: number, y?: number): Point;
}

declare class Rectangle {
	constructor(x: number, y?: number, width?: number, height?: number);
	x: number;
	y: number;
	width: number;
	height: number;
	init(x: number, y?: number, width?: number, height?: number): Rectangle;
	copyFrom(rect: Rectangle): void;
	left: number;
	right: number;
	top: number;
	bottom: number;
	clone(): Rectangle;
	equals(rect: Rectangle): boolean;
	intersection(rect: Rectangle): Rectangle;
	intersects(rect: Rectangle): boolean;
	isEmpty(): boolean;
	contains(x: number, y: number): boolean;
	containsPoint(point: TPoint): boolean;
	containsRect(rect: Rectangle): boolean;
}

declare class Entity extends ApiObject {
	getUid(): number;
	getType(): number;
	getResource(): Resource;
	getStaticBottomLayer(): Container;
	getBottomLayer(): Container;
	getStaticTopLayer(): Container;
	getTopLayer(): Container;
	getViewRootContainer(): Container;
	isOnFloor(): boolean;
	getState(): number;
	getPreviousState(): number;
	getPreviousStateGroup(): number;
	/**
	 * Sets the state of the entity without changing the animation or inducing any other side effects.
	 * @param state The state to set the entity to.
	 */
	setState(state: number): void;
	/**
	 * Transitions the entity to a new state, taking into account the object's state transition map and animation rules. Note that the the target state is not guaranteed to be the current state after this function is called, so it's important to check the state after calling this function if you need to know the result.
	 * @param state The state to transition to.
	 * @param animationOverride Overrides the animation to use for the state transition.
	 */
	toState(state: number, animationOverride?: string): void;
	/**
	 * Checks if the entity is in the specified state.
	 * @param state The state to check for.
	 * @return Bool True if the entity is in the specified state, false otherwise.
	 */
	inState(state: number): boolean;
	/**
	 * Checks if the entity is in the specified state group.
	 * @param stateGroup The state group to check for.
	 * @return Bool True if the entity is in the specified state group, false otherwise.
	 */
	inStateGroup(stateGroup: number): boolean;
	kill(): void;
	flipX(value: number): number;
	getX(): number;
	setX(pos: number): number;
	getY(): number;
	setY(pos: number): number;
	getScaleX(): number;
	/**
	 * Sets the horizontal scale of the entity.
	 * @param scaleX
	 * @return Float
	 */
	setScaleX(scaleX: number): number;
	getScaleY(): number;
	/**
	 * Sets the vertical scale of the entity.
	 * @param scaleY
	 * @return Float
	 */
	setScaleY(scaleY: number): number;
	/**
	 * Returns the unscaled x-position of the entity's pivot point
	 * @return Float
	 */
	getPivotX(): number;
	/**
	 * Returns the unscaled y-position of the entity's pivot point
	 * @return Float
	 */
	getPivotY(): number;
	/**
	 * Returns the scaled x-position of the entity's pivot point
	 * @return Float
	 */
	getPivotXScaled(): number;
	/**
	 * Returns the scaled y-position of the entity's pivot point
	 * @return Float
	 */
	getPivotYScaled(): number;
	getEcbFootX(): number;
	getEcbFootY(): number;
	getEcbHeadX(): number;
	getEcbHeadY(): number;
	getEcbLeftHipX(): number;
	getEcbLeftHipY(): number;
	getEcbRightHipX(): number;
	getEcbRightHipY(): number;
	getEcbCollisionBox(): CollisionBox;
	refreshEcb(): void;
	getCurrentFloor(): Structure;
	attachToFloor(structure: Structure): boolean;
	unattachFromFloor(): void;
	getXSpeed(): number;
	setXSpeed(speed: number): number;
	getYSpeed(): number;
	setYSpeed(speed: number): number;
	getXVelocity(): number;
	setXVelocity(speed: number): number;
	getYVelocity(): number;
	setYVelocity(speed: number): number;
	resetMomentum(): void;
	getNetSpeed(): number;
	getNetXVelocity(): number;
	getNetYVelocity(): number;
	getKnockback(): number;
	setKnockback(speed: number, angle: number): number;
	getXKnockback(): number;
	setXKnockback(speed: number): number;
	getYKnockback(): number;
	setYKnockback(speed: number): number;
	move(x: number, y: number): void;
	moveAbsolute(x: number, y: number): void;
	isFacingLeft(): boolean;
	isFacingRight(): boolean;
	faceLeft(): void;
	faceRight(): void;
	getRotation(): number;
	setRotation(value: number): number;
	resetRotation(): void;
	getAlpha(): number;
	setAlpha(value: number): number;
	getVisible(): boolean;
	setVisible(value: boolean): boolean;
	flip(): void;
	toggleGravity(status: boolean): void;
	addTimer(interval: number, repeats: number, func: () => void, options?: {condition?: () => boolean, inverseCondition?: () => boolean, pauseCondition?: () => boolean, persistent?: boolean}): number;
	removeTimer(uid: number): boolean;
	addEventListener(type: number, func: any, options?: {persistent?: boolean}): void;
	hasEventListener(type: number, func?: any): boolean;
	removeEventListener(type: number, func: any): void;
	addFilter(filter: Filter): void;
	removeFilter(filter: Filter): void;
	addShader(shader: Shader): void;
	removeShader(shader: Shader): void;
	getAnimation(): string;
	resume(): void;
	pause(): void;
	hasAnimation(animation: string): boolean;
	playAnimation(name: string): void;
	playFrame(frame: number): void;
	playFrameLabel(label: string): void;
	getCurrentFrame(): number;
	getTotalFrames(): number;
	finalFramePlayed(): boolean;
	bringInFront(gameObject: GameObject): void;
	sendBehind(gameObject: GameObject): void;
	swapDepths(gameObject: GameObject): void;
	hitTestEntity(otherEntity: Entity, selfCollisionBoxType: number, otherCollisionBoxType: number, options?: {bailEarly?: boolean, callback?: (arg0: any, arg1: CollisionResult) => boolean}): CollisionResult[];
	hitTestStructuresWithLineSegment(point1: Point, point2: Point, intersectionOut: Point, options: {collisionCheckType?: number, collisionValidator?: (physics: any, structureCollider: any, structure: any, structureType: number, collisionCheckType: number) => boolean, directionality?: boolean, excludeList?: any[], includeDisabled?: boolean, includeList?: any[], requireRicochet?: boolean, structureType?: number}): Structure[];
	getCollisionBoxes(boxType: number): CollisionBox[];
	/**
	 * Takes in a group of entities, extracts their collision data, and then tests that collision data against another entity as if the collision data belonged to this
	 * @return Array<Dynamic> The returned objects have the following structure:
	 * 		entity:EntityApi		The source entity whose collision data was responsible for the collision
	 * 		result:Rectangle		A rectangle representing the overlapping space
	 */
	collisionTestGroup(sourceEntities: Entity[], sourceBoxType: number, otherEntity: Entity, targetBoxType: number, bailEarly: boolean): {entity: Entity, result: CollisionResult}[];
	collisionTest(otherEntity: Entity, myBoxType: number, theirBoxType: number, bailEarly: boolean): Rectangle[];
	isDisposed(): boolean;
}

declare class GameObject extends Entity {
	getTeam(): number;
	getOffscreenIndicator(): OffscreenIndicator;
	getDamageCounterContainer(): Container;
	getDamageCounterRenderSprite(): Sprite;
	getScaleX(): number;
	setScaleX(scaleX: number): number;
	getScaleY(): number;
	setScaleY(scaleY: number): number;
	getAlpha(): number;
	setAlpha(value: number): number;
	getVisible(): boolean;
	setVisible(value: boolean): boolean;
	getSprite(): Sprite;
	getRootOwner(): GameObject;
	getOwner(): GameObject;
	setOwner(owner: GameObject): void;
	hasBodyStatus(flags: number): boolean;
	addStatusEffect(type: number, value?: number, options?: {fields?: {frameTimer?: TFrameTimer}, metadata?: any, params?: {interval?: number}, tag?: string}): {id: string, options?: {fields?: {frameTimer?: TFrameTimer}, metadata?: any, params?: {interval?: number}, tag?: string}, value: number};
	applyGlobalBodyStatus(status: number, duration: number): BodyStatusTimer;
	removeStatusEffect(type: number, id: string): boolean;
	findStatusEffectObjectsByTag(type: number, tag: string): {id: string, options?: {fields?: {frameTimer?: TFrameTimer}, metadata?: any, params?: {interval?: number}, tag?: string}, value: number}[];
	getStatusEffectByType(type: number): StatusEffect;
	resume(): void;
	pause(): void;
	setXVelocity(speed: number): number;
	setYVelocity(speed: number): number;
	getDamage(): number;
	addDamage(dmg: number): number;
	setDamage(dmg: number): number;
	validateHit(hitboxStats: HitboxStats): boolean;
	takeHit(hitboxStats: HitboxStats, collisionResult?: CollisionResult): boolean;
	/**
	 * Initiates processing as though a hitbox=>hurtbox collision was detected. Due to validation checks during processing, a "hit" may not occur.
	 * @param target GameObject receiving the hit
	 * @param hitboxStats Stats that determine the effect of the "hit"
	 * @param collisionResult Optional object containing "boxes" that represent the positional information of any involved hitboxes during the hit. Can be useful for generating spatially aware hit effects, and will automatically adjust built-in hit effect positioning to the specified overlap box.
	 * @return Bool True if a successful hit occurred. False if the target avoids the hit (being intangibile, in shield, etc)
	 */
	attemptHit(target: GameObject, hitboxStats: HitboxStats, collisionResult?: CollisionResult): boolean;
	/**
	 * Attempt to grab the foe.
	 * @param foe
	 * @param options Instructions for the types of grab-safety checks to ignore
	 * @return True if grab was successful
	 */
	attemptGrab(foe: GameObject, options?: {attackId?: boolean, bodyStatus?: boolean, grabLimits?: boolean, state?: boolean, team?: boolean}): boolean;
	getAnimationStat(name: string): any;
	updateAnimationStats(stats: AnimationStatsProps): void;
	getAnimationStatsMetadata(): any;
	updateAnimationStatsMetadata(stats: any): void;
	updateHitboxStats(id: number, stats: {absorbable?: boolean, angle?: number, attackId?: number, attackRatio?: number, attackStrength?: number, baseKnockback?: number, bodyX?: number, bodyY?: number, buryTimeBase?: number, buryTimeScaling?: number, buryType?: number, damage?: number, directionalInfluence?: boolean, disabled?: boolean, element?: number, flinch?: boolean, forceTumbleFall?: boolean, hitEffectOverride?: string, hitSoundOverride?: string, hitstop?: number, hitstopMultiplier?: number, hitstopNudgeMultiplier?: number, hitstopOffset?: number, hitstun?: number, index?: number, jabResetType?: number, knockbackCap?: number, knockbackCapDelay?: number, knockbackGrowth?: number, limb?: number, maxChargeDamageMultiplier?: number, metadata?: any, owner?: GameObject, rawAngle?: number, rawDamage?: number, reflectable?: boolean, reverse?: boolean, reversibleAngle?: boolean, selfHitstop?: number, selfHitstopOffset?: number, shieldDamageMultiplier?: number, shieldable?: boolean, shieldstunMultiplier?: number, stackKnockback?: boolean, tumbleType?: number, weightDependentKnockback?: number}): void;
	/**
	 * Returns the first grabbed foe in the grabbed foes array.
	 * @return The gameObjectApi object representing the grabbed foe.
	 */
	getGrabbedFoe(): GameObject;
	/**
	 * Returns all foes the grabbed foes array.
	 * @return Array of grabbed objects.
	 */
	getAllGrabbedFoes(): GameObject[];
	releaseAllCharacters(grabReleaseKb: boolean): void;
	releaseCharacter(character: Character, grabReleaseKb?: boolean): void;
	/**
	 * Refreshes the attack's UID allowing it to hit again.
	 */
	reactivateHitboxes(): void;
	getGameObjectStat(name: string): any;
	updateGameObjectStats(stats: GameObjectStatsProps): void;
	getGameObjectStatsMetadata(): any;
	updateGameObjectStatsMetadata(stats: any): void;
	getCostumeIndex(): number;
	setCostumeIndex(costumeIndex: number): void;
	getCostumeShader(): PaletteSwapShader;
	setCostumeShader(paletteSwapShader: PaletteSwapShader): void;
	getPlayerBorder(): PlayerBorder;
	setPlayerBorder(playerBorder: PlayerBorder): void;
	getHitstun(): number;
	getHitstop(): number;
	/**
	 * Forcibly starts a new set of hitstop.
	 * @param value Duration in frames
	 * @param shake True if camera should shake
	 * @see GameObjectEvent.HITSTOP_END
	 * @see GameObjectEvent.HITSTOP_START
	 */
	forceStartHitstop(value: number, shake: boolean): void;
	/**
	 * Attempts to start a new set of hitstop. Only starts a new set of hitstop if the new value is greater than the existing value.
	 * @param value Duration in frames
	 * @param shake True if camera should shake
	 * @return Bool True if a new set of hitstop was started
	 * @see GameObjectEvent.HITSTOP_END
	 * @see GameObjectEvent.HITSTOP_START
	 */
	startHitstop(value: number, shake: boolean): boolean;
	/**
	 * Forcibly starts a new set of hitstun.
	 * @param value Duration in frames
	 * @see GameObjectEvent.ENTER_HITSTUN
	 * @see GameObjectEvent.EXIT_HITSTUN
	 */
	forceStartHitstun(value: number): void;
	/**
	 * Attempts to start a new set of hitstun. Only starts a new set of hitstun if the new value is greater than the existing value.
	 * @param value Duration in frames
	 * @return Bool True if a new set of hitstop was started
	 * @see GameObjectEvent.ENTER_HITSTUN
	 * @see GameObjectEvent.EXIT_HITSTUN
	 */
	startHitstun(value: number): boolean;
	/**
	 * Returns true if the angle is within the spike threshold.
	 * @param angle
	 * @return Bool true if in the range, false if not in the range
	 */
	static angleIsInSpikeThreshold(angle: number): boolean;
}

declare class CustomGameObject extends GameObject {
	getType(): number;
	updateAnimationStats(_tmp_stats: AnimationStatsProps): void;
}

declare class Assist extends CustomGameObject {
	getPortColor(): number;
}

declare class CustomApiObject extends ApiObject {
	getOwner(): ApiObject;
	setOwner(owner: ApiObject): void;
	kill(): void;
}

declare class AssistController extends CustomApiObject {
}

/**
 * Wrapper for an Event object used to extend Event functionality
 */
declare class CustomEvent {
	type: number;
	static readonly WILDCARD: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

/**
 * Class containing all AssistEvent constants.
 */
declare class AssistEvent {
	protected constructor();
	static CUTIN: number;
	static CHARGED: number;
}

declare class DisplaySettings {
	protected constructor();
	static windowWidth: number;
	static windowHeight: number;
	static vsync: boolean;
	static pixelPerfect: boolean;
	static displayMode: number;
}

declare class CharacterAiScript extends ApiObject {
	isRecovering(): boolean;
	getImmediateTarget(): Entity;
	getTargetFoe(): Entity;
	addInputOverrides(inputList: number[]): void;
	hasInputOverrides(): boolean;
	clearInputOverrides(): void;
}

declare interface Character extends GameObject, TCharacter {
	getScore(): Score;
	getType(): number;
	getLives(): number;
	setLives(lives: number): void;
	getPlayerConfig(): PlayerConfig;
	getFoes(): Character[];
	inHurtState(): boolean;
	inStrongAttackChargeState(): boolean;
	inAerialAttackState(): boolean;
	inSpecialAttackState(): boolean;
	endAnimation(): void;
	/**
	 * This function does the necessary functions pre-landing like resetting your jumps, disabling your fastfall, etc.
	 * Note that running this function by itself will not actually put you in a landing animation necessarily.
	 * Also note that this function runs automatically when calling toLand()
	 */
	preLand(effect: boolean): void;
	/**
	 * Returns the pressed controls for the character. This data may be modified by the input buffer or other input post-processing.
	 * @return Cached ControlsObject instance containing the pressed controls data.
	 */
	getPressedControls(): ControlsObject;
	/**
	 * Returns the held controls for the character. This data may be modified by the input buffer or other input post-processing.
	 * @return Cached ControlsObject instance containing the held controls data.
	 */
	getHeldControls(): ControlsObject;
	/**
	 * Returns the raw held controls for the character. This data is not modified by the input buffer or any other input post-processing.
	 * @return Cached ControlsObject instance containing the raw held controls data.
	 */
	getRawHeldControls(): ControlsObject;
	clearInputBuffer(): void;
	/**
	 * Helper for determining if the character is in a state that should cause inputs to be buffered. This includes some non-state related conditions like being in hitstop or shieldstun.
	 * @return Returns true if inputs should be buffered during the current state.
	 */
	inBufferInputState(): boolean;
	/**
	 * Helper for checking if a state is valid state for inputs to be buffered.
	 * @return Returns true if inputs should be buffered during the specified state
	 */
	isBufferInputState(state: number): boolean;
	/**
	 * Returns true during inputUpdateHook() execution if this is the first input update check for the character on the current frame. Note that when transitioning between states there is the possibilty of multiple input update checks in a single frame due to the input buffer.
	 * @return Bool
	 */
	isFirstInputUpdate(): boolean;
	getCharacterStat(name: string): any;
	updateCharacterStats(stats: CharacterStatsProps): void;
	updateAnimationStats(_tmp_stats: AnimationStatsProps): void;
	/**
	 * Initiates a ledge-grab flow, which may or may not result in the character grabbing a ledge
	 *
	 * @return Bool True if character was not grabbing a ledge, and as a result of this function call is now grabbing ledge
	 */
	attemptLedgeGrab(): boolean;
	releaseLedge(): void;
	attachToLedge(forceBodyLock: boolean): void;
	getDoubleJumpCount(): number;
	setDoubleJumpCount(count: number): number;
	isForcedGetup(): boolean;
	playAttackVoice(): void;
	playHurtLightVoice(): void;
	playHurtMediumVoice(): void;
	playHurtHeavyVoice(): void;
	playKoVoice(): void;
	performHitstopNudge(up: boolean, down: boolean, left: boolean, right: boolean, nudgeMultiplier: number): void;
	/**
	 * Checks if character has made the necessary inputs for a STRONG.
	 *
	 * Use StrongInputType to check return values
	 */
	pressedStrongAttack(): number;
}

declare interface TCharacter {
	getAssistName(): string;
	getAssistController(): AssistController;
	getAssistContentStat(name: string): any;
	getDamageCounterAssistSprite(): Sprite;
	setAssistCutinAnimation(animation: string): void;
	getAssistCharge(): number;
	setAssistCharge(value: number): void;
	getAirdashCount(): number;
	setAirdashCount(count: number): number;
	inAirdashCanceledAnimation(): boolean;
	/**
	 * Returns color of the player's port. Returns cpuColor if character is CPU.
	 * @return Int
	 */
	getPortColor(): number;
	/**
	 * Check if eligible for zero-to-death
	 * @param self
	 * @param foe
	 * @param damageThreshold threshold damage required to be considered a zero-to-death
	 */
	checkZeroToDeath(foe: Character, damageThreshold?: number): boolean;
}

declare interface Match extends IApiObject, TMatch {
	globals: any;
	isReplay(): boolean;
	getMatchSettingsConfig(): MatchSettingsConfig;
	addEventListener(type: number, func: any, options?: {persistent?: boolean}): void;
	hasEventListener(type: number, func?: any): boolean;
	removeEventListener(type: number, func: any): void;
	getCharacters(): Character[];
	getPlayers(): Character[];
	getProjectiles(): Projectile[];
	getCustomGameObjects(): CustomGameObject[];
	getCollisionAreas(): CollisionArea[];
	getStructures(): Structure[];
	getCollisionAreaByName(name: string): CollisionArea;
	getStructureByName(name: string): Structure;
	createSpriteStructure(sprite: Sprite): Structure;
	createStructure(structureContent: string): Structure;
	createLineSegmentStructure(points: number[], stats?: StructureStats): CustomLineSegmentStructure;
	createProjectile(projectileContent: string, owner?: GameObject): Projectile;
	createCustomGameObject(customGameObjectContent: string, owner?: GameObject): GameObject;
	createCustomApiObject(customApiObjectContent: string, owner?: ApiObject): CustomApiObject;
	createRibbonTrail(sprite: Sprite, segments: number, singleAnchor: boolean): RibbonTrail;
	createVfx(vfxStats: VfxStats, owner?: GameObject): Vfx;
	createShockwaveEffect(eventData: {displacementMapId?: string, distortionEaseType?: number, distortionEnd: number, distortionStart: number, duration: number, scaleEaseType?: number, scaleEnd: number, scaleStart: number, x: number, y: number}): void;
	/**
	 * Returns time (in frames) left in the match
	 * @return Int
	 */
	getTimeLeft(): number;
	/**
	 * Returns the amount of frames that have elapsed since the match started.
	 */
	getElapsedFrames(): number;
	isDisposed(): boolean;
}

declare interface TMatch {
	overtimeCount: number;
	firstBloodCalled: boolean;
	/**
	 * Check if last 2 players and at their final stock
	 * @return Bool
	 */
	checkTwoPlayersLastLife(): boolean;
	/**
	 * Check if a valid first blood
	 * @param self
	 * @param foe
	 * @return Bool
	 */
	checkFirstBlood(foe: Character): boolean;
	/**
	 * Freezes the screen, including all game objects
	 * @param duration Length of the freeze
	 * @param allowList Entities that will be allowed to update
	 */
	freezeScreen(duration: number, allowList: GameObject[]): void;
	createVfx(vfxStats: VfxStats, owner?: GameObject): Vfx;
}

declare interface Projectile extends GameObject, TProjectile {
	getType(): number;
	getProjectileStat(name: string): any;
	updateAnimationStats(_tmp_stats: AnimationStatsProps): void;
	updateProjectileStats(stats: ProjectileStatsProps): void;
}

declare interface TProjectile {
}

declare class GraphicsSettings {
	protected constructor();
	static screenFilter: string;
	static colorBlindConfig: string;
	static launchScreen: string;
	static hudNumberShake: boolean;
	static hudReactionShake: boolean;
	static screenShake: boolean;
	static hitVfx: boolean;
	static dustVfx: boolean;
	static parryDarkenVfx: boolean;
	static stageBackgrounds: boolean;
	static damageHudPosition: string;
	static playerOutlines: string;
	static shadows: boolean;
}

declare class AiBehavior {
	protected constructor();
	/**
	 * CPUs will fight taking their normal CPU level into account. This is the default behavior for a CPU unless otherwise specified.
	 */
	static readonly ATTACK: number;
	/**
	 * CPUs will stand still while onstage, but will attempt to recover when knocked offstage. This is also the behavior for CPUs that are set to level 0.
	 */
	static readonly IDLE: number;
	/**
	 * CPUs will to avoid the player by running away, jumping, and rolling.
	 */
	static readonly EVADE: number;
	/**
	 * CPUs will walk forward constantly, turning around when approaching the edge of a stage or platform.
	 */
	static readonly WALK: number;
	/**
	 * CPUs  will constantly jump in place.
	 */
	static readonly JUMP: number;
	/**
	 * CPUs will constantly shield in place.
	 */
	static readonly SHIELD: number;
	/**
	 * CPUs will be controlled by human input.
	 */
	static readonly HUMAN: number;
}

declare class AiTechOption {
	protected constructor();
	/**
	 * CPUs will tech using their default behavior.
	 */
	static readonly DEFAULT: number;
	/**
	 * CPUs will randomly choose between missing the tech, teching in place, rolling left, and rolling right.
	 */
	static readonly RANDOM: number;
	/**
	 * CPUs will always miss techs.
	 */
	static readonly ALWAYS_MISS: number;
	/**
	 * CPUs will always tech in place.
	 */
	static readonly TECH_IN_PLACE: number;
	/**
	 * CPUs will always tech roll left.
	 */
	static readonly TECH_ROLL_LEFT: number;
	/**
	 * CPUs will always tech roll right.
	 */
	static readonly TECH_ROLL_RIGHT: number;
}

declare class AiShieldHitOption {
	protected constructor();
	/**
	 * CPUs will react to their shield being hit using their default behavior.
	 */
	static readonly DEFAULT: number;
	/**
	 * CPUs will randomly choose between doing nothing, grabbing, spot dodging, and rolling after their shield is hit.
	 */
	static readonly RANDOM: number;
	/**
	 * CPUs will continue to hold their shield for a brief period of time after their shield is hit.
	 */
	static readonly HOLD_SHIELD: number;
	/**
	 * CPUs will grab after their shield is hit.
	 */
	static readonly GRAB: number;
	/**
	 * CPUs will spot dodge after their shield is hit.
	 */
	static readonly SPOT_DODGE: number;
	/**
	 * CPUs will roll after their shield is hit.
	 */
	static readonly ROLL: number;
}

declare class AiCrashOption {
	protected constructor();
	/**
	 * CPUs will use their default CRASH_LOOP behavior.
	 */
	static readonly DEFAULT: number;
	/**
	 * CPUs will randomly choose between doing nothing, getting up, attacking, rolling left, and rolling right.
	 */
	static readonly RANDOM: number;
	/**
	 * CPUs will do nothing.
	 */
	static readonly NOTHING: number;
	/**
	 * CPUs will get up.
	 */
	static readonly GET_UP: number;
	/**
	 * CPUs will use their getup attack.
	 */
	static readonly ATTACK: number;
	/**
	 * CPUs will roll to the left.
	 */
	static readonly ROLL_LEFT: number;
	/**
	 * CPUs will roll to the right.
	 */
	static readonly ROLL_RIGHT: number;
}

declare class AiLedgeOption {
	protected constructor();
	/**
	 * CPUs will use their default ledge behavior.
	 */
	static readonly DEFAULT: number;
	/**
	 * CPUs will randomly choose between climbing, rolling, attacking, jumping, and wavedashing.
	 */
	static readonly RANDOM: number;
	/**
	 * CPUs will do nothing.
	 */
	static readonly NOTHING: number;
	/**
	 * CPUs will climb up from the ledge.
	 */
	static readonly CLIMB: number;
	/**
	 * CPUs will roll from the ledge.
	 */
	static readonly ROLL: number;
	/**
	 * CPUs will attack from the ledge.
	 */
	static readonly ATTACK: number;
	/**
	 * CPUs will jump from the ledge.
	 */
	static readonly JUMP: number;
	/**
	 * CPUs will wavedash from the ledge.
	 */
	static readonly WAVEDASH: number;
}

declare class AiDirectionalInfluenceOption {
	protected constructor();
	/**
	 * CPUs will use their default DI behavior.
	 */
	static readonly DEFAULT: number;
	/**
	 * CPUs will randomly choose a direction to DI.
	 */
	static readonly RANDOM: number;
	/**
	 * CPUs will DI according to their set level.
	 */
	static readonly CPU: number;
	/**
	 * CPUs will not DI.
	 */
	static readonly NONE: number;
	/**
	 * CPUs will DI in.
	 */
	static readonly IN: number;
	/**
	 * CPUs will DI out.
	 */
	static readonly OUT: number;
	/**
	 * CPUs will DI up.
	 */
	static readonly UP: number;
	/**
	 * CPUs will DI down.
	 */
	static readonly DOWN: number;
	/**
	 * CPUs will DI left.
	 */
	static readonly LEFT: number;
	/**
	 * CPUs will DI right.
	 */
	static readonly RIGHT: number;
	/**
	 * CPUs will DI up+left.
	 */
	static readonly UP_LEFT: number;
	/**
	 * CPUs will DI up+right.
	 */
	static readonly UP_RIGHT: number;
	/**
	 * CPUs will DI down+left.
	 */
	static readonly DOWN_LEFT: number;
	/**
	 * CPUs will DI down+right.
	 */
	static readonly DOWN_RIGHT: number;
}

declare class AiHitstopNudgeOption {
	protected constructor();
	/**
	 * CPUs will use their default hitstop nudge behavior.
	 */
	static readonly DEFAULT: number;
	/**
	 * CPUs will randomly choose a direction to nudge.
	 */
	static readonly RANDOM: number;
	/**
	 * CPUs will nudge according to their set level.
	 */
	static readonly CPU: number;
	/**
	 * CPUs will not nudge.
	 */
	static readonly NONE: number;
	/**
	 * CPUs will nudge in.
	 */
	static readonly IN: number;
	/**
	 * CPUs will nudge out.
	 */
	static readonly OUT: number;
	/**
	 * CPUs will nudge up.
	 */
	static readonly UP: number;
	/**
	 * CPUs will nudge down.
	 */
	static readonly DOWN: number;
	/**
	 * CPUs will nudge left.
	 */
	static readonly LEFT: number;
	/**
	 * CPUs will nudge right.
	 */
	static readonly RIGHT: number;
	/**
	 * CPUs will nudge up+left.
	 */
	static readonly UP_LEFT: number;
	/**
	 * CPUs will nudge up+right.
	 */
	static readonly UP_RIGHT: number;
	/**
	 * CPUs will nudge down+left.
	 */
	static readonly DOWN_LEFT: number;
	/**
	 * CPUs will nudge down+right.
	 */
	static readonly DOWN_RIGHT: number;
}

declare class StructureType {
	protected constructor();
	static readonly NONE: number;
	static readonly LEFT_WALL: number;
	static readonly RIGHT_WALL: number;
	static readonly CEILING: number;
	static readonly FLOOR: number;
	static readonly AUTO: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class TPoint {
	constructor(x: number, y?: number);
	distance(point: TPoint): number;
	/**
	 * Fast relative distance calculator
	 */
	distanceSquared(point: TPoint): number;
	init(x: number, y?: number): TPoint;
	copyFrom(point: TPoint): void;
	/**
	 * Adds other into this point, returns this
	 * @param other The other point to add
	 * @return New point after combining the points together
	 */
	add(other: TPoint): TPoint;
	clone(): TPoint;
	scale(x: number, y: number): void;
	offset(x: number, y: number): void;
	equals(point: TPoint): boolean;
	static polar(len: number, angle: number, outPoint?: TPoint): TPoint;
	static interpolate(point1: TPoint, point2: TPoint, fraction: number): TPoint;
	/**
	 * Gets the interesection between two line segments (or null if no intersection can be found)
	 * @param a0 First point of line segment A
	 * @param a1 Second point of line segment A
	 * @param b0 First point of line segment B
	 * @param b1  Second point of line segment B
	 * @param out An existing point object to be used as a return value instead of allocating a new Point.
	 * @return Point The point at which the two line segments intersect (or null if there is no intersection)
	 */
	static lineSegmentsIntersect(a0: TPoint, a1: TPoint, b0: TPoint, b1: TPoint, out?: TPoint): TPoint;
}

/**
 * ...
 * @author
 */
declare class JSONClass {
	constructor(settings: any);
	/**
	 * Imports data from JSON data and overrides multiple fields within the JSONClass instance at once
	 * @param data 	A JSON-like object of any type
	 */
	importJSON(data: any): void;
	/**
	 * Exports the class as generic Dynamic JSON data
	 *
	 * @return JSON-like data object
	 */
	exportJSON(): any;
}

/**
 * A class containing parameters that configures the default settings of a Match.
 * Any player-affecting parameters will be overridden by the PlayerConfig.
 */
declare class MatchSettingsConfig extends JSONClass {
	/**
	 * A class containing parameters that configures the default settings of a Match.
	 * Any player-affecting parameters will be overridden by the PlayerConfig.
	 */
	constructor(settings: {damageMode?: boolean, damageRatio?: number, entrances?: boolean, hazards?: boolean, lives?: number, matchRules?: {contentId: string, namespace: string, resourceId: string}[], metadata?: any, music?: {contentId: string, namespace: string, resourceId: string}, netcodeInputBuffer?: number, netcodeType?: number, pauseMenuId?: string, playerIDs?: boolean, preloadMediaMap?: any, randSeed?: string, sizeRatio?: number, specialModes?: number, stage?: {contentId: string, namespace: string, resourceId: string}, startDamage?: number, teamAttack?: boolean, teams?: boolean, time?: number});
	/**
	 * The content/resource ID of the Stage that the Match takes place on.
	 */
	stage: {contentId: string, namespace: string, resourceId: string};
	/**
	 * This setting specifies the music resource id and content id to be loaded and played at match start
	 */
	music: {contentId: string, namespace: string, resourceId: string};
	/**
	 * A multiplier for the default scale of sprites within this Match.
	 * Generally this should be left alone, as it does not have additional effects like scaling physics or damage.
	 */
	sizeRatio: number;
	/**
	 * Number of 'stocks' each player has by default within this Match. Note that this can be overridden by playerConfigs.
	 * - Set to -1 to disable.
	 */
	lives: number;
	/**
	 * Damage mode for the players.
	 * - true for damage
	 * - false for stamina
	 */
	damageMode: boolean;
	/**
	 * Match game timer IN SECONDS.
	 * - Set negative to count up from 0 to value.
	 * - Set positive to count down from value.
	 * - Set to 0 to disable.
	 */
	time: number;
	/**
	 * Set to true to make player ID numbers display above each player at all times.
	 */
	playerIDs: boolean;
	/**
	 * Starting damage for players.
	 * - Set to negative to give players stamina instead of racking up damage.
	 * @see stamina
	 */
	startDamage: number;
	/**
	 * This value is applied to the global knockback formula when a game object takes damage.
	 * - Do note that as the damage scales, so does the distance a foe goes upon being hit.
	 */
	damageRatio: number;
	/**
	 * Set to true to make the match a team battle. Set to false for a free-for-all.
	 * - When having a team battle make sure to assign each player (via PlayerConfig) to a team.
	 */
	teams: boolean;
	/**
	 * Controls whether friendly fire is enabled.
	 * - When set to true, teammates can hurt each other.
	 * - This has no effect outside of team battles.
	 */
	teamAttack: boolean;
	/**
	 * Controls whether stage hazards are enabled. The definition of 'hazard' varies by stage.
	 * - When set to true, stages' hazardous elements are enabled.
	 * - When set to false, they are disabled.
	 */
	hazards: boolean;
	/**
	 * This is a bit mapping of the enabled special modes for a match.
	 * In order to combine special modes together, you need to perform a bitwise OR on the special modes you would like to enable.
	 */
	specialModes: number;
	/**
	 * This is the random seed that was set at match start.
	 * You may retrieve this value if desired but **this should not be set manually.**
	 */
	randSeed: string;
	/**
	 * Netcode setting. This determines the type of Match instance to instantiate.
	 */
	netcodeType: number;
	/**
	 * The input delay setting of the match host. For delay-based matches, all players will use the same input delay. For rollback-based matches, the settings are determined at an individual player level.
	 */
	netcodeInputBuffer: number;
	/**
	 * When true, character entrance animations will be shown at the start of a match. Set to false to disable this behavior.
	 */
	entrances: boolean;
	/**
	 * The content/resource ID of the match rules for this match.
	 */
	matchRules: {contentId: string, namespace: string, resourceId: string}[];
	/**
	 * The pause config for this match.
	 */
	pauseMenuId: string;
	/**
	 * Dynamic metadata - use this for anything else not covered by existing variables.
	 */
	metadata: any;
	/**
	 * netcodeType value: No netcode is enabled
	 */
	static readonly NETCODE_NONE: number;
	/**
	 * netcodeType value: Delay-based netcode is enabled
	 */
	static readonly NETCODE_DELAY: number;
	/**
	 * netcodeType value: Rollback netcode is enabled
	 */
	static readonly NETCODE_ROLLBACK: number;
	/**
	 * netcodeType value: Rollback netcode is simualted offline
	 */
	static readonly NETCODE_ROLLBACK_SIMULATED: number;
}

declare var CState:CState;
declare type CState = TCState & {
	constructor();
	UNINITIALIZED: number;
	DISABLED: number;
	STAND: number;
	STAND_TURN: number;
	INTRO: number;
	REVIVAL: number;
	WALK_IN: number;
	WALK_LOOP: number;
	WALK_OUT: number;
	DASH: number;
	DASH_PIVOT: number;
	RUN: number;
	RUN_TURN: number;
	SKID: number;
	JUMP_SQUAT: number;
	JUMP_IN: number;
	JUMP_LOOP: number;
	JUMP_OUT: number;
	JUMP_MIDAIR: number;
	FALL: number;
	FALL_SPECIAL: number;
	LAND: number;
	CROUCH_IN: number;
	CROUCH_LOOP: number;
	CROUCH_OUT: number;
	CRAWL_FORWARD: number;
	CRAWL_BACK: number;
	LEDGE_IN: number;
	LEDGE_LOOP: number;
	LEDGE_CLIMB_IN: number;
	LEDGE_CLIMB: number;
	LEDGE_ROLL_CLIMB: number;
	LEDGE_ROLL: number;
	LEDGE_JUMP_IN: number;
	LEDGE_JUMP: number;
	LEDGE_ATTACK_IN: number;
	LEDGE_ATTACK: number;
	SHIELD_IN: number;
	SHIELD_LOOP: number;
	SHIELD_OUT: number;
	SHIELD_BREAK: number;
	SHIELD_HURT: number;
	SHIELD_AIR: number;
	ROLL: number;
	SPOT_DODGE: number;
	TECH: number;
	TECH_ROLL: number;
	TECH_WALL: number;
	TECH_CEILING: number;
	PARRY_IN: number;
	PARRY_FAIL: number;
	PARRY_SUCCESS: number;
	HURT_LIGHT: number;
	HURT_MEDIUM: number;
	HURT_HEAVY: number;
	HURT_HEAVY_HITSTOP: number;
	HURT_PARRY_STUN: number;
	TUMBLE: number;
	CRASH_BOUNCE: number;
	CRASH_LOOP: number;
	CRASH_ATTACK: number;
	CRASH_ROLL: number;
	CRASH_GET_UP: number;
	JAB: number;
	DASH_ATTACK: number;
	TILT_FORWARD: number;
	TILT_UP: number;
	TILT_DOWN: number;
	STRONG_FORWARD_IN: number;
	STRONG_FORWARD_CHARGE: number;
	STRONG_FORWARD_ATTACK: number;
	STRONG_UP_IN: number;
	STRONG_UP_CHARGE: number;
	STRONG_UP_ATTACK: number;
	STRONG_DOWN_IN: number;
	STRONG_DOWN_CHARGE: number;
	STRONG_DOWN_ATTACK: number;
	AERIAL_NEUTRAL: number;
	AERIAL_FORWARD: number;
	AERIAL_BACK: number;
	AERIAL_UP: number;
	AERIAL_DOWN: number;
	SPECIAL_NEUTRAL: number;
	SPECIAL_SIDE: number;
	SPECIAL_UP: number;
	SPECIAL_DOWN: number;
	THROW_UP: number;
	THROW_DOWN: number;
	THROW_FORWARD: number;
	THROW_BACK: number;
	ACTION: number;
	GRAB: number;
	GRAB_HOLD: number;
	GRAB_PUMMEL: number;
	HELD: number;
	KO: number;
	EMOTE: number;
	BURIED: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	constToString(value: number): string;
}

declare type TCState = {
	constructor();
	UNINITIALIZED: number;
	DISABLED: number;
	STAND: number;
	STAND_TURN: number;
	INTRO: number;
	REVIVAL: number;
	WALK_IN: number;
	WALK_LOOP: number;
	WALK_OUT: number;
	DASH: number;
	DASH_PIVOT: number;
	RUN: number;
	RUN_TURN: number;
	SKID: number;
	JUMP_SQUAT: number;
	JUMP_IN: number;
	JUMP_LOOP: number;
	JUMP_OUT: number;
	JUMP_MIDAIR: number;
	FALL: number;
	FALL_SPECIAL: number;
	LAND: number;
	CROUCH_IN: number;
	CROUCH_LOOP: number;
	CROUCH_OUT: number;
	CRAWL_FORWARD: number;
	CRAWL_BACK: number;
	LEDGE_IN: number;
	LEDGE_LOOP: number;
	LEDGE_CLIMB_IN: number;
	LEDGE_CLIMB: number;
	LEDGE_ROLL_CLIMB: number;
	LEDGE_ROLL: number;
	LEDGE_JUMP_IN: number;
	LEDGE_JUMP: number;
	LEDGE_ATTACK_IN: number;
	LEDGE_ATTACK: number;
	SHIELD_IN: number;
	SHIELD_LOOP: number;
	SHIELD_OUT: number;
	SHIELD_BREAK: number;
	SHIELD_HURT: number;
	SHIELD_AIR: number;
	ROLL: number;
	SPOT_DODGE: number;
	TECH: number;
	TECH_ROLL: number;
	TECH_WALL: number;
	TECH_CEILING: number;
	PARRY_IN: number;
	PARRY_FAIL: number;
	PARRY_SUCCESS: number;
	HURT_LIGHT: number;
	HURT_MEDIUM: number;
	HURT_HEAVY: number;
	HURT_HEAVY_HITSTOP: number;
	HURT_PARRY_STUN: number;
	TUMBLE: number;
	CRASH_BOUNCE: number;
	CRASH_LOOP: number;
	CRASH_ATTACK: number;
	CRASH_ROLL: number;
	CRASH_GET_UP: number;
	JAB: number;
	DASH_ATTACK: number;
	TILT_FORWARD: number;
	TILT_UP: number;
	TILT_DOWN: number;
	STRONG_FORWARD_IN: number;
	STRONG_FORWARD_CHARGE: number;
	STRONG_FORWARD_ATTACK: number;
	STRONG_UP_IN: number;
	STRONG_UP_CHARGE: number;
	STRONG_UP_ATTACK: number;
	STRONG_DOWN_IN: number;
	STRONG_DOWN_CHARGE: number;
	STRONG_DOWN_ATTACK: number;
	AERIAL_NEUTRAL: number;
	AERIAL_FORWARD: number;
	AERIAL_BACK: number;
	AERIAL_UP: number;
	AERIAL_DOWN: number;
	SPECIAL_NEUTRAL: number;
	SPECIAL_SIDE: number;
	SPECIAL_UP: number;
	SPECIAL_DOWN: number;
	THROW_UP: number;
	THROW_DOWN: number;
	THROW_FORWARD: number;
	THROW_BACK: number;
	ACTION: number;
	GRAB: number;
	GRAB_HOLD: number;
	GRAB_PUMMEL: number;
	HELD: number;
	KO: number;
	EMOTE: number;
	BURIED: number;
	AIRDASH_DELAY: number;
	AIRDASH_INITIAL: number;
	AIRDASH_ACCELERATING: number;
	AIRDASH_FULL_SPEED: number;
	AIRDASH_DECELERATING: number;
	AIRDASH_ENDING: number;
	ASSIST_CALL: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	constToString(value: number): string;
}

declare var CStateGroup:CStateGroup;
declare type CStateGroup = TCStateGroup & {
	constructor();
	UNINITIALIZED: number;
	INTRO: number;
	DASH: number;
	WALK: number;
	RUN: number;
	JUMP: number;
	CROUCH: number;
	LEDGE: number;
	LEDGE_ROLL: number;
	SHIELD: number;
	PARRY: number;
	HURT_HEAVY: number;
	CRASH: number;
	ATTACK: number;
	GRAB: number;
	KO: number;
	CRAWL: number;
	LEDGE_CLIMB: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	constToString(value: number): string;
}

declare type TCStateGroup = {
	constructor();
	UNINITIALIZED: number;
	INTRO: number;
	DASH: number;
	WALK: number;
	RUN: number;
	JUMP: number;
	CROUCH: number;
	LEDGE: number;
	LEDGE_ROLL: number;
	SHIELD: number;
	PARRY: number;
	HURT_HEAVY: number;
	CRASH: number;
	ATTACK: number;
	GRAB: number;
	KO: number;
	CRAWL: number;
	LEDGE_CLIMB: number;
	AIRDASH: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	constToString(value: number): string;
}

declare class GlobalSfx {
	protected constructor();
	static ASSIST_CALL: string;
	static ASSIST_CHARGED_P1: string;
	static ASSIST_CHARGED_P2: string;
	static ASSIST_CHARGED_P3: string;
	static ASSIST_CHARGED_P4: string;
	static AIRDASH: string;
	static PARRY: string;
	static HIT_LIGHT: string;
	static HIT_MEDIUM: string;
	static HIT_HEAVY: string;
	static JUMP_STARTUP: string;
	static JUMP: string;
	static CROUCH: string;
	static LEDGE_GRAB: string;
	static SHIELD: string;
	static CRASH_BOUNCE: string;
	static CRASH_NORMAL: string;
	static GRAB_CONFIRM: string;
	static GROUND_BOUNCE: string;
	static KO_BLAST: string;
	static GROUNDED_SPIKE: string;
	static CRASH_1: string;
	static CRASH_2: string;
	static DOUBLE_JUMP: string;
	static FATAL_BASH: string;
	static FATAL_ELECTRIC_HIT: string;
	static FATAL_FIRE_HIT: string;
	static FATAL_ICE_HIT: string;
	static FATAL_KICK: string;
	static FATAL_MAGIC_HIT: string;
	static FATAL_POISON_HIT: string;
	static FATAL_PUNCH: string;
	static FATAL_SLAM: string;
	static FATAL_SLICE: string;
	static FATAL_WHACK: string;
	static STRONG_CHARGE: string;
	static STRONG_CLICK: string;
	static HEAVY_BASH: string;
	static HEAVY_ELECTRIC_HIT: string;
	static HEAVY_FIRE_HIT: string;
	static HEAVY_ICE_HIT: string;
	static HEAVY_KICK: string;
	static HEAVY_MAGIC_HIT: string;
	static HEAVY_POISON_HIT: string;
	static HEAVY_PUNCH: string;
	static HEAVY_SLAM: string;
	static HEAVY_SLICE: string;
	static HEAVY_WHACK: string;
	static LAND: string;
	static LIGHT_BASH: string;
	static LIGHT_ELECTRIC_HIT: string;
	static LIGHT_FIRE_HIT: string;
	static LIGHT_ICE_HIT: string;
	static LIGHT_KICK: string;
	static LIGHT_MAGIC_HIT: string;
	static LIGHT_POISON_HIT: string;
	static LIGHT_PUNCH: string;
	static LIGHT_SLAM: string;
	static LIGHT_SLICE: string;
	static LIGHT_WHACK: string;
	static MEDIUM_BASH: string;
	static MEDIUM_ELECTRIC_HIT: string;
	static MEDIUM_FIRE_HIT: string;
	static MEDIUM_ICE_HIT: string;
	static MEDIUM_KICK: string;
	static MEDIUM_MAGIC_HIT: string;
	static MEDIUM_POISON_HIT: string;
	static MEDIUM_PUNCH: string;
	static MEDIUM_SLAM: string;
	static MEDIUM_SLICE: string;
	static MEDIUM_WHACK: string;
	static MENU_CANCEL: string;
	static MENU_CLICK: string;
	static MENU_COSTUME_DOWN: string;
	static MENU_COSTUME_UP: string;
	static MENU_ERROR: string;
	static MENU_HOVER: string;
	static MENU_ICON_ENTER: string;
	static MENU_SELECT: string;
	static MENU_SIDES_CLOSE: string;
	static MENU_STAGE_BACK: string;
	static MENU_STAGE_ENTER: string;
	static MENU_STAGE_SELECT: string;
	static MENU_STARTUP: string;
	static ROLL: string;
	static SHIELD_HIT_0: string;
	static SHIELD_HIT_1: string;
	static SHIELD_HIT_2: string;
	static SHIELD_HIT_3: string;
	static SHIELD_HIT_4: string;
	static SHIELD_HIT_5: string;
	static SHIELD_HIT_6: string;
	static SPOT_DODGE: string;
	static WHOOSH_1: string;
	static WHOOSH_2: string;
	static WHOOSH_3: string;
}

declare class GlobalVfx {
	protected constructor();
	static AIRDASH: string;
	static AIRDASH_BACK: string;
	static REVIVAL: string;
	static DUST_START_HEAVY: string;
	static JUMP_TRAIL: string;
	static DOUBLE_JUMP_DUST: string;
	static DOUBLE_JUMP_DUST_BACK: string;
	static KNOCKBACK_SMOKE: string;
	static CRASH_BOUNCE: string;
	static CRASH_BOUNCE_BACK: string;
	static CRASH_NORMAL: string;
	static GROUND_BOUNCE: string;
	static GROUND_BOUNCE_BACK: string;
	static LAND_DUST: string;
	static LAND_DUST_BACK: string;
	static SPARKLE_FASTFALL: string;
	static KO_BLAST: string;
	static CLANK: string;
	static GROUNDED_SPIKE: string;
	static GROUNDED_SPIKE_BACK: string;
	static MEDIUM_NORMAL_HIT: string;
	static DUST_START_LIGHT: string;
	static DUST_THROUGH: string;
	static DUST_SPIN: string;
	static DUST_POOF: string;
	static DUST_POOF_BACK: string;
	static DUST_SPIN_BACK: string;
	static SPARKLE_LIGHT: string;
	static SPARKLE_HEAVY: string;
	static SPIKE: string;
	static SPIKE_BACK: string;
	static LIGHT_NORMAL_HIT: string;
	static LIGHT_NORMAL_HIT_BACK: string;
	static MEDIUM_NORMAL_HIT_BACK: string;
	static HEAVY_NORMAL_HIT: string;
	static HEAVY_NORMAL_HIT_BACK: string;
	static FATAL_NORMAL_HIT: string;
	static FATAL_NORMAL_HIT_BACK: string;
	static LIGHT_NORMAL_ANGLED_HIT: string;
	static LIGHT_NORMAL_ANGLED_HIT_BACK: string;
	static MEDIUM_NORMAL_ANGLED_HIT: string;
	static MEDIUM_NORMAL_ANGLED_HIT_BACK: string;
	static HEAVY_NORMAL_ANGLED_HIT: string;
	static HEAVY_NORMAL_ANGLED_HIT_BACK: string;
	static FATAL_NORMAL_ANGLED_HIT: string;
	static FATAL_NORMAL_ANGLED_HIT_BACK: string;
}

/**
 * AnimationStats is the base class for animation behavior of GameObjects.
 */
declare class AnimationStats extends JSONClass {
	constructor(settings: AnimationStatsProps);
	/**
	 * The name of the attack animation.
	 */
	name: string;
	/**
	 * Percentage of non-KB X Speed kept on frame 1
	 */
	xSpeedConservation: number;
	/**
	 * Percentage of non-KB Y Speed kept on frame 1
	 */
	ySpeedConservation: number;
	/**
	 * Override's the BodyStatus of the Entity for the duration of the animation.
	 */
	bodyStatus: number;
	/**
	 * If BodyStatus is in the DAMAGE_ARMOR, DAMAGE_RESISTANCE, LAUNCH_ARMOR, or LAUNCH_RESISTANCE states, then this controls the damage and velocity thresholds for each respective status.
	 */
	bodyStatusStrength: number;
	/**
	 * Multiplier that is applied to the object's gravity value
	 */
	gravityMultiplier: number;
	/**
	 * Determines the behavior of the object when it transitions from air to ground.
	 * @see: LandType
	 */
	landType: number;
	/**
	 * If non-null, the name of the animation that will be jumped to when the object transitions from air to ground, regardless of landType
	 * If null, the engine will use a land animation based on the landType
	 */
	landAnimation: string;
	/**
	 * Limit of the amount of objects that can be grabbed during this animation
	 */
	grabLimit: number;
	/**
	 * Total number of frames the animation has been charged for
	 */
	chargeFramesTotal: number;
	/**
	 * Maximum number of frames the animation can be charged for. Setting this value to zero will disable charge incrementing
	 */
	chargeFramesMax: number;
	/**
	 * Whether or not the character can slide off the edge of a floor.
	 */
	slideOff: boolean;
	/**
	 * If enabled the entity will have their animation canceled if they transition from grounded to aerial.
	 * @deprecated Characters can use leaveGroundType instead
	 */
	leaveGroundCancel: boolean;
	/**
	 * Whether or not to enable shadows on this particular animation
	 */
	shadows: boolean;
	/**
	 * Defines how the engine should handle the completion of this animation
	 * @see AnimationEndType
	 */
	endType: number;
	/**
	 * Used in conjunction with AnimationEndType.AUTO. If provided, when the animation ends, the entity's state will be changed to this value
	 */
	nextState: number;
	/**
	 * Used in conjunction with AnimationEndType.AUTO.  If provided, when the animation ends, the entity's animation will be changed to this value
	 */
	nextAnimation: string;
	/**
	 * When true, the current AnimationStats attackId will be reset on the first frame.
	 */
	resetId: boolean;
	/**
	 * If true, the entity's body rotates to match momentum.
	 */
	autoRotate: boolean;
	/**
	 * Set to true and the object will push other solid animations when hurtboxes overlap, unless those objects are immovable or non-solid.
	 */
	solid: boolean;
	/**
	 * Immovable animations do not take knockback from windboxes and cannot be pushed by other solid objects, but may still push other movable solid objects.
	 */
	immovable: boolean;
	/**
	 * When set to true, animation playback is halted on the current frame.
	 */
	pause: boolean;
	/**
	 * When a non-zero value, the object will rotate at the specified speed. Positive values will rotate clockwise, while negative values will rotate counter-clockwise. Note that if the object is flipped horizontally, the direction of the rotation will also be flipped.
	 */
	rotationSpeed: number;
	/**
	 * When true, the rotation of the object will be reset on the first frame.
	 */
	resetRotation: boolean;
	/**
	 * Ground speed acceleration override for this animation. Resorts to default groundSpeedAcceleration GameObject stat when set to a negative value.
	 */
	groundSpeedAcceleration: number;
	/**
	 * Air speed acceleration override for this animation. Resorts to default aerialSpeedAcceleration GameObject stat when set to a negative value.
	 */
	aerialSpeedAcceleration: number;
	/**
	 * Maximum ground speed limit override for this animation. Resorts to default groundSpeedCap GameObject stat when set to a negative value.
	 */
	groundSpeedCap: number;
	/**
	 * Maximum air speed limit override for this animation. Resorts to default aerialSpeedCap GameObject stat when set to a negative value.
	 */
	aerialSpeedCap: number;
	/**
	 * Terminal velocity override for this animation. Resorts to default terminalVelocity GameObject stat when set to a negative value.
	 */
	terminalVelocity: number;
	/**
	 * Metadata passed into the attack
	 */
	metadata: any;
	/**
	 * Not to be set directly - unique attackId for the attack
	 */
	attackId: number;
	/**
	 * Allows the animation to be counted as a free state. Note that modifying this value directly will bypass any special rules surrounding interruptibility (i.e. IASA that relies on external conditions).
	 */
	interruptible: boolean;
	/**
	 * Not to be set directly - tracks the previously stored charge percentage
	 */
	storedChargePercent: number;
	/**
	 * Clean resets the animation stats. Since animation stats are constantly being re-imported, this provides a faster way to restore defaults before importing new stats.
	 */
	init(): void;
	/**
	 * Utility function for updating the metadata object of the stats without changing the metadata object's reference. Performs a shallow merge of all fields from the input data
	 * @param data The data to merge into the metadata
	 */
	updateMetadata(data: any): void;
}

declare class AssistAnimationStats extends AnimationStats {
	constructor(settings: AssistAnimationStatsProps);
}

/**
 * Stats for a tangible ingame object that appears in a match.
 */
declare class GameObjectStats extends JSONClass {
	constructor(settings: GameObjectStatsProps);
	/**
	 * Content id path of the sprite to load for this GameObject
	 */
	spriteContent: string;
	/**
	 * The initial state the object should be set to.
	 */
	initialState: number;
	/**
	 * Map of states to animations/callbacks
	 */
	stateTransitionMapOverrides: { [key: number]: {airAnimation?: string, animation?: string, inputHook?: () => void, inputInterrupt?: () => boolean, postTransitionHook?: () => void, preTransitionHook?: (arg0: number) => void, stateGroup?: number, transitionInterrupt?: (arg0: number) => boolean, updateHook?: () => void, updateInterrupt?: () => boolean} };
	/**
	 * Multiplies the base horizontal scale of the GameObject by the specified amount. The object will render by default at a multiple of baseScaleX and baseScaleY. Note that currently Special Angles AUTOLINK_STRONGER and AUTOLINK_STRONGEST will not function properly if this is set to a value other than 1.0.
	 */
	baseScaleX: number;
	/**
	 * Multiplies the base vertical scale of the GameObject by the specified amount. The object will render by default at a multiple of baseScaleX and baseScaleY. Note that currently Special Angles AUTOLINK_STRONGER and AUTOLINK_STRONGEST will not function properly if this is set to a value other than 1.0.
	 */
	baseScaleY: number;
	/**
	 * Head collision point based on the relative vertical distance from the object's origin when the object is grounded. Note that positive numbers will have their signed flipped automatically since the head position can never be beneath the object's origin point, so you may use positive numbers as a shorthand. The head position will also be forced to be no lower than the foot. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	floorHeadPosition: number;
	/**
	 * Width of wall collision detection area surrounding the object while grounded. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	floorHipWidth: number;
	/**
	 * Horizontally displaces the position of the hips from the base position of the object by the specified value when the object is grounded. At zero, the left and right hips are evenly displaced on both sides. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	floorHipXOffset: number;
	/**
	 * Vertically displaces the wall collision detection area on the object relative to the foot when the object is grounded. At zero, the hip is placed vertically halfway between the object's head and foot. This is the base value which is used when no collision body data is available. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	floorHipYOffset: number;
	/**
	 * Foot collision point based on the relative vertical distance from the object's origin when the object is grounded. Note that positive numbers will have their signed flipped automatically since the foot position can never be beneath the object's origin point, so you may use positive numbers as a shorthand. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	floorFootPosition: number;
	/**
	 * Head collision point based on the relative vertical distance from the object's origin when the object is grounded. Note that positive numbers will have their signed flipped automatically since the head position can never be beneath the object's origin point, so you may use positive numbers as a shorthand. The head position will also be forced to be no lower than the foot. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	aerialHeadPosition: number;
	/**
	 * Width of wall collision detection area surrounding the object when the object is grounded. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	aerialHipWidth: number;
	/**
	 * Horizontally displaces the position of the hips from the base position of the object by the specified value when the object is grounded. At zero, the left and right hips are evenly displaced on both sides. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	aerialHipXOffset: number;
	/**
	 * Vertically displaces the wall collision detection area on the object relative to the foot when the object is grounded. At zero, the hip is placed vertically halfway between the object's head and foot. This is the base value which is used when no collision body data is available. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	aerialHipYOffset: number;
	/**
	 * Foot collision point based on the relative vertical distance from the object's origin when the object is grounded. Note that positive numbers will have their signed flipped automatically since the foot position can never be beneath the object's origin point, so you may use positive numbers as a shorthand. Game Objects can override this value on specific animation frames by containing an ECB baked into the animation.
	 */
	aerialFootPosition: number;
	/**
	 * Offsets the X position of the camera box surrounding the object.
	 */
	cameraBoxOffsetX: number;
	/**
	 * Offsets the Y position of the camera box surrounding the object.
	 */
	cameraBoxOffsetY: number;
	/**
	 * Width of the camera box surrounding the object. The top left of the camera box will always be positioned so that it is mirrored over the Y-axis, with the bottom of the box flushed against the X axis. Use cameraBoxOffsetX to adjust the X positioning from there.
	 */
	cameraBoxWidth: number;
	/**
	 * Height of the camera box surrounding the object. The top left of the camera box will always be positioned so that it is mirrored over the Y-axis, with the bottom of the box flushed against the X axis. Use cameraBoxOffsetY to adjust the Y positioning from there.
	 */
	cameraBoxHeight: number;
	/**
	 * Used to determine how hard the ground shakes when the Entity lands or hits a wall, also used to determine how light the Entity is for knockback velocity purposes.
	 */
	weight: number;
	/**
	 * Deceleration rate on the ground.
	 */
	friction: number;
	/**
	 * Fall acceleration.
	 */
	gravity: number;
	/**
	 * The terminal velocity of the owner Entity. This is the maximum limit to the speed at which an Entity can fall. Please note however that knockback is not taken into account.
	 */
	terminalVelocity: number;
	/**
	 * Multiplier that is applied to knockback which gets assigned to HitboxStats on attack hit.  This is similar to damageRatio but is instead applied to outgoing attacks from this object. This is especially useful for scaling up difficulty during single player matches.
	 */
	attackRatio: number;
	/**
	 * Multiplier that is applied to received knockback.  This is similar to attackRatio but is instead applied to incoming attacks. This is especially useful for scaling up difficulty during single player matches.
	 */
	damageRatio: number;
	/**
	 * The deceleration speed of the game object if forward is not held and they're in the air.
	 */
	aerialFriction: number;
	/**
	 * Game object's ground speed acceleration.
	 */
	groundSpeedAcceleration: number;
	/**
	 * Game object's aerial drift acceleration (and deceleration if holding the opposite direction).
	 */
	aerialSpeedAcceleration: number;
	/**
	 * Max horizontal speed when in the air.
	 */
	groundSpeedCap: number;
	/**
	 * Max horizontal speed when in the air.
	 */
	aerialSpeedCap: number;
	/**
	 * Solid entities' animations push other solid objects away unless their immovable stat true, and can be pushed by other solid objects unless their own immovable stat is true.
	 */
	solid: boolean;
	/**
	 * Immovable objects are immune to windboxes and cannot be pushed by other solid entities. They will still push other solid objects if both the object and animation's solid stat is true.
	 */
	immovable: boolean;
	/**
	 * Whether or not to enable structure collisions.
	 */
	ghost: boolean;
	/**
	 * Whether or not to enable shadows globally on the game object.
	 */
	shadows: boolean;
	/**
	 * Whether or not to destroy the object when it touches a stage's death bounds
	 */
	deathBoundsDestroy: boolean;
	/**
	 * Additional Metadata
	 */
	metadata: any;
	/**
	 * Utility function for updating the metadata object of the stats without changing the metadata object's reference. Performs a shallow merge of all fields from the input data
	 * @param data The data to merge into the metadata
	 */
	updateMetadata(data: any): void;
}

declare class AssistStats extends GameObjectStats {
	constructor(settings: AssistStatsProps);
	/**
	 * Amount of damage required to fully charge the assist (default damage is 100).
	 */
	assistChargeValue: number;
	/**
	 * If the assist render has a separate background layer (postfixed with _bg), it will get placed behind the assist render on the hud and cut-in
	 * If this value is TRUE, the background layer will be layered before the "trail / repeating after-image effect" on the assist cut-in
	 */
	assistBgBeforeTrail: boolean;
}

declare class CameraShakeType {
	protected constructor();
	/**
	 * No camera shake should occur.
	 */
	static readonly NONE: number;
	/**
	 * Camera shake will be automatically calculated by the engine.
	 */
	static readonly AUTO: number;
}

declare interface CharacterAnimationStats extends AnimationStats, TCharacterAnimationStats {
	new(settings: CharacterAnimationStatsProps);
	/**
	 * Set to true for attack animations that can only be used once when initiated in mid-air.
	 */
	singleUse: boolean;
	/**
	 * When true the character will be capable of flipping their direction faced on the first frame of the animation when the opposite direction is tapped prior to the animation.
	 */
	allowTurn: boolean;
	/**
	 * When true the character will be capable of flipping their direction faced by tapping a left or right direction for the duration of the animation.
	 */
	allowTurnOnFirstFrame: boolean;
	/**
	 * When true the character will accept fast fall inputs while in the air during the animation.
	 */
	allowFastFall: boolean;
	/**
	 * When true the character will be able to jump cancel the animation.
	 */
	allowJump: boolean;
	/**
	 * Set to true to make upward momentum from a double jump cancel when this move is used.
	 */
	doubleJumpCancel: boolean;
	/**
	 * If set to true the entity will be able to grab ledges from behind them if the type of object allows.
	 */
	grabLedgeBehind: boolean;
	/**
	 * If set to true the entity will be able to grab ledges while rising.
	 */
	grabLedgeRising: boolean;
	/**
	 * When true, the player can influence the character's movement during this animation.
	 */
	allowMovement: boolean;
	/**
	 * Determines the behaviour of the Character when becoming airborne.
	 * @see LeaveGroundType
	 */
	leaveGroundType: number;
	leaveGroundAnimation: string;
	/**
	 * The color filter used when a body status is active. Can set to 0x000000 to disable.
	 */
	bodyStatusShaderColor: number;
}

declare interface TCharacterAnimationStats {
	new(settings: CharacterAnimationStatsProps);
	/**
	 * When true, landing during this animation will ignore the value of landAnimation and send the character to the default landing animation.
	 */
	autocancel: boolean;
	/**
	 * When true, the engine will apply its built-in charge shake animation to the character sprites.
	 */
	chargeShake: boolean;
	/**
	 * When true, the engine will apply its built-in charge glow animation to the character sprites.
	 */
	chargeGlow: boolean;
}

declare interface CharacterStats extends GameObjectStats, TCharacterStats {
	new(settings: CharacterStatsProps);
	/**
	 * The unique name of the character. Used for finding the object.
	 */
	name: string;
	/**
	 * Character's grounded vertical jump speed. Values less than or equal to zero will disable the character's ability to jump from the ground
	 */
	jumpSpeed: number;
	/**
	 * Horizontal speed initially given if holding forward when jump startup ends. Set to less than or equal to 0 to disable.
	 */
	jumpSpeedForwardInitialXSpeed: number;
	/**
	 * Horizontal speed initially given if holding backward when jump startup ends. Set to greater than or equal to 0 to disable.
	 */
	jumpSpeedBackwardInitialXSpeed: number;
	/**
	 * An array of the character's double jump speeds. Values less than or equal to zero will have no effect. The number of entries in the array correlates with how many double jumps the character will get from the engine.
	 */
	doubleJumpSpeeds: number[];
	/**
	 * The speed of a short-hop.
	 */
	shortHopSpeed: number;
	/**
	 * Horizontal speed boost the character gets when performing a ledge jump
	 */
	ledgeJumpXSpeed: number;
	/**
	 * Vertical speed boost the character gets when performing a ledge jump
	 */
	ledgeJumpYSpeed: number;
	/**
	 * The speed at which a character falls during a fast fall
	 */
	fastFallSpeed: number;
	/**
	 * How long the character can float. 0 to disable.
	 */
	floatDuration: number;
	/**
	 * Speed the character starts gliding at. 0 to disable.
	 */
	initialGlideSpeed: number;
	/**
	 * Speed the character's tech roll begins at.
	 */
	techRollSpeed: number;
	/**
	 * Frame that tech roll speed begins to be applied on.
	 */
	techRollSpeedStartFrame: number;
	/**
	 * How many frames of speed are applied during tech roll.
	 */
	techRollSpeedLength: number;
	/**
	 * Speed the character's dodge roll begins at.
	 */
	dodgeRollSpeed: number;
	/**
	 * Frame that dodge roll speed begins to be applied on.
	 */
	dodgeRollSpeedStartFrame: number;
	/**
	 * How many frames of speed are applied during dodge roll.
	 */
	dodgeRollSpeedLength: number;
	/**
	 * Speed the character's getup roll begins at.
	 */
	getupRollSpeed: number;
	/**
	 * Frame that getup roll speed begins to be applied on.
	 */
	getupRollSpeedStartFrame: number;
	/**
	 * How many frames of speed are applied during getup roll.
	 */
	getupRollSpeedLength: number;
	/**
	 * Speed the character's ledge roll begins at.
	 */
	ledgeRollSpeed: number;
	/**
	 * Frame that ledge roll speed begins to be applied on.
	 */
	ledgeRollSpeedStartFrame: number;
	/**
	 * How many frames of speed are applied during ledge roll.
	 */
	ledgeRollSpeedLength: number;
	/**
	 * Character's initial walk speed.
	 */
	walkSpeedInitial: number;
	/**
	 * Character's walk speed acceleration.
	 */
	walkSpeedAcceleration: number;
	/**
	 * Character's max walk speed.
	 */
	walkSpeedCap: number;
	/**
	 * Character's initial run speed.
	 */
	dashSpeed: number;
	/**
	 * Character's initial run speed (post-turn only).
	 */
	runSpeedInitial: number;
	/**
	 * Character's run speed acceleration.
	 */
	runSpeedAcceleration: number;
	/**
	 * Character's max run speed.
	 */
	runSpeedCap: number;
	/**
	 * Character's crawl speed. Set to 0 to disable crawling.
	 */
	crawlSpeed: number;
	/**
	 * If set to true, jumps after the second can be performed by holding jump.
	 */
	holdToJump: boolean;
	/**
	 * List of attack voice content ids. Calls to playAttackVoice() will choose one of these audio clips at random.
	 */
	attackVoiceIds: string[];
	/**
	 * List of hurt light voice content ids. Calls to playHurtLightVoice() will choose one of these audio clips at random.
	 */
	hurtLightVoiceIds: string[];
	/**
	 * List of hurt medium voice content ids. Calls to playHurtMediumVoice() will choose one of these audio clips at random.
	 */
	hurtMediumVoiceIds: string[];
	/**
	 * List of hurt heavy voice content ids. Calls to playHurtHeavyVoice() will choose one of these audio clips at random.
	 */
	hurtHeavyVoiceIds: string[];
	/**
	 * List of KO blast voice content ids. Calls to playKoVoice() will choose one of these audio clips at random.
	 */
	koVoiceIds: string[];
	/**
	 * The rate at which calls to playAttackVoice() should result in silence.
	 */
	attackVoiceSilenceRate: number;
	/**
	 * The rate at which calls to playHurtLightVoice() should result in silence.
	 */
	hurtLightSilenceRate: number;
	/**
	 * The rate at which calls to playHurtMediumVoice() should result in silence.
	 */
	hurtMediumSilenceRate: number;
	/**
	 * The rate at which calls to playHurtHeavyVoice() should result in silence.
	 */
	hurtHeavySilenceRate: number;
	/**
	 * The rate at which calls to playKoVoice() should result in silence.
	 */
	koVoiceSilenceRate: number;
	/**
	 * The behaviour of performing GRAB while midair
	 */
	grabAirType: number;
	/**
	 * The animation the character will use when buried.
	 */
	buryAnimation: string;
	/**
	 * The frame of the buryAnimation to be used while buried.
	 */
	buryFrame: number;
	/**
	 * Vertical offset for the bury animation, relative to their ECB's vertical midpoint.
	 */
	buryOffsetY: number;
}

declare interface TCharacterStats {
	new(settings: CharacterStatsProps);
	/**
	 * The ID of the trail effect that you want airdashes to spawn
	 */
	airdashTrailEffect: string;
	/**
	 * Radial distance away from the center point of the character that the air dash effect is drawn
	 */
	airdashEffectRadius: number;
	/**
	 * X offset of the air dash effect center point relative to the horizontal center of the character's body
	 */
	airdashEffectOffsetX: number;
	/**
	 * Y offset of the air dash effect center point relative to the vertical center of the character's body
	 */
	airdashEffectOffsetY: number;
	/**
	 * How much camera shake the engine should apply at the beginning on your airdash
	 */
	airdashCameraShakeIntensity: number;
	/**
	 * Airdash initial speed
	 */
	airdashInitialSpeed: number;
	/**
	 * Number of frames at airdashInitialSpeed (note, gravity is enabled) before acceleration
	 */
	airdashStartupLength: number;
	/**
	 * The percentage of airdash momentum that is added each frame during accel phase
	 */
	airdashAccelMultiplier: number;
	/**
	 * The percentage of the airdash speed that will be conserved when canceling an airdash with an attack
	 */
	airdashCancelSpeedConservation: number;
	/**
	 * Airdash max speed
	 */
	airdashSpeedCap: number;
	/**
	 * Number of frames at airdashSpeedCap before deceleration starts
	 */
	airdashFullspeedLength: number;
	/**
	 * Airdash endlag speed
	 */
	airdashEndlagSpeed: number;
	/**
	 * Number of frames at airdashEndlagSpeed
	 */
	airdashEndlagLength: number;
	/**
	 * Maximum number of times the character can air dash before landing (Set to 0 to disable, or negative for infinite)
	 */
	airdashLimit: number;
	/**
	 * Nine slice to use for the front shield
	 */
	shieldFrontNineSliceContent: string;
	/**
	 * Horizontal offset of the character's front shield relative to the center of their body dimensions
	 */
	shieldFrontXOffset: number;
	/**
	 * Vertical offset of the character's front shield relative to the center of their body dimensions
	 */
	shieldFrontYOffset: number;
	/**
	 * Width of the front shield graphic
	 */
	shieldFrontWidth: number;
	/**
	 * Height of the front shield graphic
	 */
	shieldFrontHeight: number;
	/**
	 * Nine slice to use for the back shield
	 */
	shieldBackNineSliceContent: string;
	/**
	 * Horizontal offset of the character's back shield relative to the center of their body dimensions
	 */
	shieldBackXOffset: number;
	/**
	 * Vertical offset of the character's back shield relative to the center of their body dimensions
	 */
	shieldBackYOffset: number;
	/**
	 * Width of the back shield graphic
	 */
	shieldBackWidth: number;
	/**
	 * Height of the back shield graphic
	 */
	shieldBackHeight: number;
	/**
	 * Minimum distance behind character that attacker must be to get a cross-up
	 */
	shieldCrossupThreshold: number;
}

declare interface HitboxStats extends JSONClass, THitboxStats {
	new(settings: {absorbable?: boolean, angle?: number, attackId?: number, attackRatio?: number, attackStrength?: number, baseKnockback?: number, bodyX?: number, bodyY?: number, buryTimeBase?: number, buryTimeScaling?: number, buryType?: number, damage?: number, directionalInfluence?: boolean, disabled?: boolean, element?: number, flinch?: boolean, forceTumbleFall?: boolean, hitEffectOverride?: string, hitSoundOverride?: string, hitstop?: number, hitstopMultiplier?: number, hitstopNudgeMultiplier?: number, hitstopOffset?: number, hitstun?: number, index?: number, jabResetType?: number, knockbackCap?: number, knockbackCapDelay?: number, knockbackGrowth?: number, limb?: number, maxChargeDamageMultiplier?: number, metadata?: any, owner?: GameObject, rawAngle?: number, rawDamage?: number, reflectable?: boolean, reverse?: boolean, reversibleAngle?: boolean, selfHitstop?: number, selfHitstopOffset?: number, shieldDamageMultiplier?: number, shieldable?: boolean, shieldstunMultiplier?: number, stackKnockback?: boolean, tumbleType?: number, weightDependentKnockback?: number});
	/**
	 * The numerical index of the hitbox that can be used to identify which hitbox was involved in a hit.
	 */
	index: number;
	/**
	 * Attack identfier for the stats
	 */
	attackId: number;
	/**
	 * Setting to false will make the move not break grabs nor send the foe into the hurt animation.
	 */
	flinch: boolean;
	/**
	 * The amount of damage that the hitbox deals to foes.
	 */
	damage: number;
	/**
	 * Multiplier for shield damage.
	 */
	shieldDamageMultiplier: number;
	/**
	 * Multiplier for shieldstun.
	 */
	shieldstunMultiplier: number;
	/**
	 * A multiplier that is applied to knockback after the final knockback calculation has been done.
	 */
	attackRatio: number;
	/**
	 * Growth of the power correlated to damage.
	 */
	knockbackGrowth: number;
	/**
	 * Base power.
	 */
	baseKnockback: number;
	/**
	 * The angle of knockback. Expects an angle between 0 and 360, or alternatively a SpecialAngle value. Note that when a foe takes damage this number is modified in the resulting HIT_RECEIVED/HIT_DEALT GameObjectEvents. Use rawAngle if you want the original value.
	 */
	angle: number;
	/**
	 * Multiplier for how far foes can nudge while in hitstop.
	 */
	hitstopNudgeMultiplier: number;
	/**
	 * Determines how many frames the victim will be held in place before knockback is applied. When negative this value is automatically calculated.
	 */
	hitstop: number;
	/**
	 * Determines how many frames the attacker will be held in place before knockback is applied. When negative this value is automatically calculated.
	 */
	selfHitstop: number;
	/**
	 * Used in conjunction with a negative hitstop stat, adds a flat amount of hitstop independent of how hitstop is calculated.
	 */
	hitstopOffset: number;
	/**
	 * Used in conjunction with a negative selfHitstop stat, adds a flat amount of hitstop independent of how selfHitstop is calculated.
	 */
	selfHitstopOffset: number;
	/**
	 * Multiplier that affects both hitstop and selfHitstop.
	 */
	hitstopMultiplier: number;
	/**
	 * How long the foe will be unable to attack after knockback is applied. When positive, this is the number of frames the foe will remain in hitstun. When negative, this works like a multiplier against the automatically calculated hitstun value. For example, a value of -0.5 would result in a multiplier of 0.5 against the calculated hitstun. By leaving it at its default of -1, you will get 100% of the calculated hitstun.
	 */
	hitstun: number;
	/**
	 * Multiplier used for maximum charge if the move is chargeable
	 */
	maxChargeDamageMultiplier: number;
	/**
	 * Instead of using the automatic hitsound calc (uses element and hitstrength).
	 */
	hitSoundOverride: string;
	/**
	 * Use a custom hit Vfx. By default, the engine assumes this is an animation name from from the GlobalVfx sprite (See GlobalVfx constnats). You can however use other Vfx animations by specifying the full content id of the Vfx sprite followed by a hash "#" specifying the animation you want to play. (e.g. "namespace::resource.spriteId#animationId")
	 */
	hitEffectOverride: string;
	/**
	 * What the attacker is attacking with.
	 * @see AttackLimb
	 */
	limb: number;
	/**
	 * What element the attack is
	 * @see AttackElement
	 */
	element: number;
	/**
	 * Use this alongside the element to determine the hit sound and hit effect.
	 * @see AttackStrength
	 */
	attackStrength: number;
	/**
	 * The GameObjectApi instance that owns the hitbox.
	 */
	owner: GameObject;
	/**
	 * X location of the owner GameObject. Generally this is auto-populated to match the position of the owner, except in cases HitboxStats were generated by hand in which case an owning object may not exist.
	 */
	bodyX: number;
	/**
	 * Y location of the owner GameObject. Generally this is auto-populated to match the position of the owner, except in cases HitboxStats were generated by hand in which case an owning object may not exist.
	 */
	bodyY: number;
	/**
	 * If true, the hitbox will behave as though it did not exist (it will not interact with other boxes).
	 */
	disabled: boolean;
	/**
	 * When true, if the hitbox connects behind the origin of the attacker then the resulting angle will be flipped horizontally.
	 */
	reversibleAngle: boolean;
	/**
	 * @deprecated When true, the attack will always cause foes to go into their tumble state when hit. This stat has been deprecated, please use tumbleType stat instead
	 */
	forceTumbleFall: boolean;
	/**
	 * Tumble settings
	 * @see TumbleType
	 */
	tumbleType: number;
	/**
	 * Setting to false will disable knockback stacking.
	 */
	stackKnockback: boolean;
	/**
	 * Setting to false will disable post-hitstop directional influence among hit foes.
	 */
	directionalInfluence: boolean;
	/**
	 * When true, the hitbox is able to trigger absorb-related events when it connects with an absorb collision box. Absorb events are only receivable by projectiles, and the resulting behavior is determined by the individual projectile receiving the absorb event.
	 */
	absorbable: boolean;
	/**
	 * When true, the hitbox is able to trigger reflect-related events when it connects with a reflect box. Reflect events are only receivable by projectiles and items, and the resulting behavior is determined by the individual object receiving the reflect event.
	 */
	reflectable: boolean;
	/**
	 * When true, the hitbox is able to be shielded by foes.
	 */
	shieldable: boolean;
	/**
	 * Jab reset settings
	 * @see JabResetType
	 */
	jabResetType: number;
	/**
	 * When true, the hitbox will automatically reverse and flip most other object types objects upon a successful hit.
	 */
	reverse: boolean;
	/**
	 * When greater than or equal to zero, prevents an attack from dealing more knockback than this value. When negative, knockback is unlimited.
	 */
	knockbackCap: number;
	/**
	 * Number of frames to delay the application of knockbackCap. When negative or zero, knockbackCap is immediately applied. When 1, the cap will be applied on the next frame.
	 */
	knockbackCapDelay: number;
	/**
	 * Bury settings. Only affects Characters.
	 * @see BuryType
	 */
	buryType: number;
	/**
	 * Base amount of frames a buried target will stay buried for.
	 */
	buryTimeBase: number;
	/**
	 * Amount of extra frames a buried target will stay buried for; a scaling applied to the target's percent.
	 */
	buryTimeScaling: number;
	/**
	 * Additional metadata.
	 */
	metadata: any;
	/**
	 * The raw damage value of the hitbox. Is unaffected by staling and cannot be assigned.
	 */
	rawDamage: number;
	/**
	 * The raw angle value of the hitbox that always starts equal to the "angle" stat. Cannot be assigned, but you can use it to determine the original angle of the hitbox in cases where the actual trajectory of the foe isn't desired.
	 */
	rawAngle: number;
	/**
	 * Utility function for updating the metadata object of the stats without changing the metadata object's reference. Performs a shallow merge of all fields from the input data
	 * @param data The data to merge into the metadata
	 */
	updateMetadata(data: any): void;
	afterImportJSON(data: any): void;
}

declare interface THitboxStats {
	new(settings: HitboxStatsProps);
	/**
	 * Specifies the camera shake behavior for the hit.
	 */
	cameraShakeType: number;
}

declare interface ProjectileAnimationStats extends AnimationStats, TProjectileAnimationStats {
	new(settings: ProjectileAnimationStatsProps);
	init(): void;
}

declare interface TProjectileAnimationStats {
	new(settings: ProjectileAnimationStatsProps);
}

declare interface ProjectileStats extends GameObjectStats, TProjectileStats {
	new(settings: ProjectileStatsProps);
	/**
	 * Whether or not this projectile resizes when spawned by a resized parent.
	 */
	resizable: boolean;
}

declare interface TProjectileStats {
	new(settings: ProjectileStatsProps);
}

declare var StatusEffectType:StatusEffectType;
declare type StatusEffectType = TStatusEffectType & {
	constructor();
	JUMP_SPEED_MULTIPLIER: number;
	DAMAGE_OVER_TIME: number;
	DISABLE_ACTION: number;
	SIZE_MULTIPLIER: number;
	WIDTH_MULTIPLIER: number;
	HEIGHT_MULTIPLIER: number;
	HITBOX_DAMAGE_MULTIPLIER: number;
	ATTACK_KNOCKBACK_MULTIPLIER: number;
	ATTACK_HITSTOP_MULTIPLIER: number;
	ALPHA_MULTIPLIER: number;
	INVISIBILITY: number;
	AERIAL_FRICTION_MULTIPLIER: number;
	GROUND_FRICTION_MULTIPLIER: number;
	ATTACK_HITSTOP_FLAT: number;
	ATTACK_SELF_HITSTOP_FLAT: number;
	ATTACK_HITSTUN_MULTIPLIER: number;
	ATTACK_HITSTUN_FLAT: number;
	ATTACK_SELF_HITSTOP_MULTIPLIER: number;
	GRAVITY_MULTIPLIER: number;
	SHORT_HOP_SPEED_MULTIPLIER: number;
	DOUBLE_JUMP_SPEED_MULTIPLIER: number;
	TERMINAL_VELOCITY_MULTIPLIER: number;
	FAST_FALL_SPEED_MULTIPLIER: number;
	WALK_SPEED_INITIAL_MULTIPLIER: number;
	WALK_SPEED_CAP_MULTIPLIER: number;
	DASH_SPEED_MULTIPLIER: number;
	RUN_SPEED_INITIAL_MULTIPLIER: number;
	RUN_SPEED_ACCELERATION_MULTIPLIER: number;
	RUN_SPEED_CAP_MULTIPLIER: number;
	GROUND_SPEED_ACCELERATION_MULTIPLIER: number;
	GROUND_SPEED_CAP_MULTIPLIER: number;
	AERIAL_SPEED_ACCELERATION_MULTIPLIER: number;
	AERIAL_SPEED_CAP_MULTIPLIER: number;
	DAMAGE_LOCKED: number;
	CUSTOM: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	constToString(value: number): string;
}

declare type TStatusEffectType = {
	constructor();
	JUMP_SPEED_MULTIPLIER: number;
	DAMAGE_OVER_TIME: number;
	DISABLE_ACTION: number;
	SIZE_MULTIPLIER: number;
	WIDTH_MULTIPLIER: number;
	HEIGHT_MULTIPLIER: number;
	HITBOX_DAMAGE_MULTIPLIER: number;
	ATTACK_KNOCKBACK_MULTIPLIER: number;
	ATTACK_HITSTOP_MULTIPLIER: number;
	ALPHA_MULTIPLIER: number;
	INVISIBILITY: number;
	AERIAL_FRICTION_MULTIPLIER: number;
	GROUND_FRICTION_MULTIPLIER: number;
	ATTACK_HITSTOP_FLAT: number;
	ATTACK_SELF_HITSTOP_FLAT: number;
	ATTACK_HITSTUN_MULTIPLIER: number;
	ATTACK_HITSTUN_FLAT: number;
	ATTACK_SELF_HITSTOP_MULTIPLIER: number;
	GRAVITY_MULTIPLIER: number;
	SHORT_HOP_SPEED_MULTIPLIER: number;
	DOUBLE_JUMP_SPEED_MULTIPLIER: number;
	TERMINAL_VELOCITY_MULTIPLIER: number;
	FAST_FALL_SPEED_MULTIPLIER: number;
	WALK_SPEED_INITIAL_MULTIPLIER: number;
	WALK_SPEED_CAP_MULTIPLIER: number;
	DASH_SPEED_MULTIPLIER: number;
	RUN_SPEED_INITIAL_MULTIPLIER: number;
	RUN_SPEED_ACCELERATION_MULTIPLIER: number;
	RUN_SPEED_CAP_MULTIPLIER: number;
	GROUND_SPEED_ACCELERATION_MULTIPLIER: number;
	GROUND_SPEED_CAP_MULTIPLIER: number;
	AERIAL_SPEED_ACCELERATION_MULTIPLIER: number;
	AERIAL_SPEED_CAP_MULTIPLIER: number;
	DAMAGE_LOCKED: number;
	CUSTOM: number;
	AIRDASH_CANCEL_SPEED_CONSERVATION_MULTIPLIER: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	constToString(value: number): string;
}

/**
 * A class containing parameters that configures the default settings of a Character in a match.
 * These override values given in the MatchConfig.
 */
declare interface PlayerConfig extends JSONClass, TPlayerConfig {
	/**
	 * A class containing parameters that configures the default settings of a Match.
	 * Any player-affecting parameters will be overridden by the PlayerConfig.
	 */
	constructor(settings: {attackRatio?: number, character?: {contentId: string, namespace: string, resourceId: string}, clientUid?: string, costume?: number, cpu?: boolean, damageMode?: boolean, damageRatio?: number, isRandom?: boolean, level?: number, lives?: number, metadata?: any, name?: string, playerBorder?: PlayerBorder, port?: number, startDamage?: number, team?: number});
	/**
	 * Player Port #
	 */
	port: number;
	/**
	 * The content/resource ID of the character to load for the player. If set to null, this player slot will be considered empty.
	 */
	character: {contentId: string, namespace: string, resourceId: string};
	/**
	 * The player tag to display above the character during the match.
	 */
	name: string;
	/**
	 * Whether or not this player is a cpu (when false, the player will be human-controlled).
	 */
	cpu: boolean;
	/**
	 * The CPU level for the player. Set to 0 to make the player human.
	 */
	level: number;
	/**
	 * A multiplier that is applied to knockback caused by this player's attacks.
	 */
	attackRatio: number;
	/**
	 * A multiplier that is applied to receiving knockback from the attacks of other players. This is a local setting that overrides the global damageRatio coming from level data settings.
	 */
	damageRatio: number;
	/**
	 * Assigns the player to a specified team. This is only applicable of the team setting is set to true within the level data settings for the match.
	 * -1 = No team.
	 * 0 = Red team.
	 * 1 = Green team.
	 * 2 = Blue team.
	 * 3 = Yellow team.
	 */
	team: number;
	/**
	 * Specify a border to show on this player
	 */
	playerBorder: PlayerBorder;
	/**
	 * Assigns a costume to the player. If this value set to a negative number, the default costume will be used. Otherwise this value corresponds to the index of the costume within the character's costume array.
	 */
	costume: number;
	/**
	 * The number of lives for this player. This overrides the stock provided by the level data setting's lives value if it is not set to -1.
	 */
	lives: number;
	/**
	 * Starting damage for players. This overrides the startDamage value provided by the level data settings for the match unless set to -1.
	 */
	startDamage: number;
	/**
	 * Damage mode for the player.
	 * - true for damage
	 * - false for stamina
	 */
	damageMode: boolean;
	/**
	 * Returns true if the player picked Random.
	 */
	isRandom: boolean;
	/**
	 * Online mode only - used to determine player ports.
	 */
	clientUid: string;
	/**
	 * Dynamic metadata - use this for anything else not covered by existing variables.
	 */
	metadata: any;
}

/**
 * A class containing parameters that configures the default settings of a Character in a match.
 * These override values given in the MatchConfig.
 */
declare interface TPlayerConfig {
	new(settings: {assist?: {contentId: string, namespace: string, resourceId: string}, assistBorder?: PlayerBorder, assistCostume?: number, attackRatio?: number, character?: {contentId: string, namespace: string, resourceId: string}, clientUid?: string, costume?: number, cpu?: boolean, damageMode?: boolean, damageRatio?: number, isRandom?: boolean, level?: number, lives?: number, metadata?: any, name?: string, playerBorder?: PlayerBorder, port?: number, startAssistCharge?: number, startDamage?: number, team?: number, unlimitedAssist?: boolean});
	/**
	 * The content/resource ID of the assist to load for the player. If set to null, this assist slot will be considered empty.
	 */
	assist: {contentId: string, namespace: string, resourceId: string};
	/**
	 * Assigns a costume to the assist. If this value set to a negative number, the default costume will be used. Otherwise this value corresponds to the index of the costume within the assist's costume array.
	 */
	assistCostume: number;
	/**
	 * Starting assist charge for players. This overrides the startAssistCharge value provided by the level data settings for the match unless set to -1.
	 */
	startAssistCharge: number;
	/**
	 * Unlimited final strongs?
	 */
	unlimitedAssist: boolean;
	/**
	 * Specify a border to show on this assist
	 */
	assistBorder: PlayerBorder;
}

declare class AiGraphNode extends Entity {
	getType(): number;
	setX(pos: number): number;
	setY(pos: number): number;
}

declare class Engine {
	static log(msg: any, color?: number): void;
	static makeUid(): number;
	/**
	 * Utility method for running a for...in loop against a list that leverages the engine for more efficiency. Use this for demanding for loops with large lists to improve performance.
	 * @param list The array containing the elements to loop through.
	 * @param callback A callback method to run that will receive the current iteratee as its first argument, and index integer as its second argument. If this callback returns false, the loop will be ceased immediately.
	 * @param args Any additional arguments to pass to the callback method (Set to empty array [] if you desire no additional arguments)
	 */
	static forEach(list: any[], callback: any, args: any[]): void;
	/**
	 * Utility method for running a for loop with a given duration that leverages the engine for more efficiency. Use this for demanding for loops with large lists to improve performance.
	 * @param count Number of times the for loop should run.
	 * @param callback A callback method to run that will receive the current zero-indexed loop number as its first argument. If this callback returns false, the loop will be ceased immediately.
	 * @param args Any additional arguments to pass to the callback method (Set to empty array [] if you desire no additional arguments)
	 */
	static forCount(count: number, callback: any, args: any[]): void;
	/**
	 * Returns formatted timestamp given # of frames. Includes milliseconds.
	 * @param numFrames
	 * @return String
	 */
	static framesToTimeString(numFrames: number): string;
	/**
	 * Returns formatted timestamp given # of frames. Does not include milliseconds.
	 * @param numFrames
	 * @return String
	 */
	static framesToTimeStringShort(numFrames: number): string;
}

declare class ApiVarArray extends ASerializable {
	get(): any[];
	set(value: any[]): any[];
}

declare class ApiVarBool {
	get(): boolean;
	set(value: boolean): boolean;
}

declare class ApiVarFloat {
	get(): number;
	set(value: number): number;
	add(value: number): number;
	mult(value: number): number;
	inc(): number;
	dec(): number;
}

declare class ApiVarInt {
	get(): number;
	set(value: number): number;
	add(value: number): number;
	mult(value: number): number;
	inc(): number;
	dec(): number;
}

declare class ApiVarObject extends ASerializable {
	get(): any;
	set(value: any): any;
}

declare class ApiVarString {
	get(): string;
	set(value: string): string;
}

declare class AudioClip {
	stop(): void;
	pause(): void;
	resume(): void;
	isPlaying(): boolean;
	isFinished(): boolean;
	isDisposed(): boolean;
	/**
	 * Plays audio by the specified id, returning the active AudioClip object of the played audio.
	 * @param audioContent The content id path of the audio to be played.
	 * @param options Playback options for the audio
	 * @return AudioClip Instance of the audio that was played.
	 */
	static play(audioContent: string, options?: PlaySoundArgs): AudioClip;
}

/**
 * Constants representing each possible button inputs.
 */
declare class Buttons {
	protected constructor();
	static UP: number;
	static DOWN: number;
	static LEFT: number;
	static RIGHT: number;
	static ATTACK: number;
	static SPECIAL: number;
	static ACTION: number;
	static JUMP: number;
	static SHIELD: number;
	static SHIELD1: number;
	static SHIELD2: number;
	static GRAB: number;
	static EMOTE: number;
	static PAUSE: number;
	static RIGHT_STICK_UP: number;
	static RIGHT_STICK_DOWN: number;
	static RIGHT_STICK_LEFT: number;
	static RIGHT_STICK_RIGHT: number;
	static DASH: number;
	static SHORT_HOP: number;
	static SHIELD_AIR: number;
	static TAP_JUMP: number;
	static CROUCH: number;
	static TILT: number;
	static STRONG: number;
}

declare class Camera extends ApiObject {
	getX(): number;
	getY(): number;
	getViewportWidth(): number;
	getViewportHeight(): number;
	getZoomScaleX(): number;
	getZoomScaleY(): number;
	addEventListener(type: number, func: any, options?: {persistent?: boolean}): void;
	hasEventListener(type: number, func?: any): boolean;
	removeEventListener(type: number, func: any): void;
	getBackgroundContainers(): Container[];
	/**
	 * Adjust a background container's view body offset. Useful for creating automatic scroll.
	 * @param index Index of the background to offset
	 * @param x X offset
	 * @param y Y offset
	 */
	setBackgroundOffset(index: number, x: number, y: number): void;
	shake(intensity: number, duration?: number, frequency?: number, waveType?: number, decayType?: number, customWaveSamples?: number[], customDecaySamples?: number[]): void;
	horizontalShake(intensity: number, duration?: number, frequency?: number, waveType?: number, decayType?: number, customWaveSamples?: number[], customDecaySamples?: number[]): void;
	verticalShake(intensity: number, duration?: number, frequency?: number, waveType?: number, decayType?: number, customWaveSamples?: number[], customDecaySamples?: number[]): void;
	addForcedTarget(entity: Entity): void;
	addTarget(entity: Entity): void;
	addTimedTarget(entity: Entity, length: number): void;
	addTimedTargetPoint(point: Point, length: number): void;
	deleteForcedTarget(entity: Entity): void;
	deleteTarget(entity: Entity): void;
	deleteTimedTarget(entity: Entity): void;
	deleteTimedTargetPoint(point: Point): void;
	getMode(): number;
	setMode(mode: number): number;
	getBackgroundContainer(): Container;
	getForegroundContainer(): Container;
	getParallaxSprites(): Sprite[];
	isDisposed(): boolean;
}

declare class CollisionArea extends Entity {
	getType(): number;
	getPreviousX(): number;
	getPreviousY(): number;
	hitTestRect(rect: Rectangle, shapeFlag?: boolean): boolean;
	hitTestPoint(x: number, y: number, shapeFlag?: boolean): boolean;
	getCollisionAreaStat(name: string): any;
	updateCollisionAreaStats(stats: {disabled?: boolean, startX?: number, startY?: number}): void;
}

declare class DisplayObject extends ASerializable {
	isDisposed(): boolean;
	addFilter(filter: Filter): void;
	removeFilter(filter: Filter): void;
	x: number;
	y: number;
	scaleX: number;
	scaleY: number;
	width: number;
	height: number;
	rotation: number;
	visible: boolean;
	alpha: number;
	transformationMatrix: Matrix;
	remove(): void;
	equals(displayObjectApi: DisplayObject): boolean;
	kill(): void;
}

declare class Container extends DisplayObject {
	addChild(displayObjectApi: DisplayObject): void;
	addChildAt(displayObjectApi: DisplayObject, index: number): void;
	removeChild(displayObjectApi: DisplayObject): void;
	static create(): Container;
}

declare class Structure extends Entity {
	getType(): number;
	getStructureStat(name: string): any;
	updateStructureStats(stats: {accelFriction?: number, animationId?: string, conserveDownwardMomentum?: boolean, conserveHorizontalMomentum?: boolean, conserveUpwardMomentum?: boolean, decelFriction?: number, disableShadows?: boolean, disabled?: boolean, dropThrough?: boolean, foregroundAnimationId?: string, foregroundSpriteContent?: string, influenceX?: number, land?: boolean, leftLedge?: boolean, leftLedgeSize?: number, ricochet?: boolean, rightLedge?: boolean, rightLedgeSize?: number, spriteContent?: string, startX?: number, startY?: number, structureType?: number}): void;
	addToWhitelist(gameObject: GameObject): void;
	removeFromWhitelist(gameObject: GameObject): void;
	isWhitelisted(gameObject: GameObject): boolean;
	addToBlacklist(gameObject: GameObject): void;
	removeFromBlacklist(gameObject: GameObject): void;
	isBlacklisted(gameObject: GameObject): boolean;
}

declare class CustomLineSegmentStructure extends Structure {
	updatePoints(points: number[]): void;
}

declare class Filter extends ASerializable {
	kill(): void;
}

declare class DisplacementFilter extends Filter {
	constructor(inNormalMap: Tile, dispX?: number, dispY?: number, wrap?: boolean);
	setNormalMap(value: Tile): void;
	dispX: number;
	dispY: number;
	wrap: boolean;
}

declare class Drawable extends DisplayObject {
	addShader(shader: Shader): void;
	removeShader(shader: Shader): void;
	colorAdd: number;
}

/**
 * Position easing utility that takes a "from" and a "to" point and calculates the points between the two. Utilizes a FrameTimer behind the scenes.
 *
 * Algorithm source: https://gist.github.com/gre/1650294
 */
declare class TBaseEaseTimer extends ASerializable {
	constructor(from: number, to: number, length: number, easeType?: number);
	readonly value: number;
	update(): void;
	isCompleted(): boolean;
	reset(): void;
	static interpolate(from: number, to: number, t: number, easeType?: number): number;
	static readonly LINEAR: number;
	static readonly EASE_IN_QUAD: number;
	static readonly EASE_OUT_QUAD: number;
	static readonly EASE_IN_OUT_QUAD: number;
	static readonly EASE_IN_CUBIC: number;
	static readonly EASE_OUT_CUBIC: number;
	static readonly EASE_IN_OUT_CUBIC: number;
	static readonly EASE_IN_QUART: number;
	static readonly EASE_OUT_QUART: number;
	static readonly EASE_IN_OUT_QUART: number;
	static readonly EASE_IN_QUINT: number;
	static readonly EASE_OUT_QUINT: number;
	static readonly EASE_IN_OUT_QUINT: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class EaseTimer extends TBaseEaseTimer {
	constructor(from: number, to: number, length: number, easeType?: number);
	static readonly LINEAR: number;
	static readonly EASE_IN_QUAD: number;
	static readonly EASE_OUT_QUAD: number;
	static readonly EASE_IN_OUT_QUAD: number;
	static readonly EASE_IN_CUBIC: number;
	static readonly EASE_OUT_CUBIC: number;
	static readonly EASE_IN_OUT_CUBIC: number;
	static readonly EASE_IN_QUART: number;
	static readonly EASE_OUT_QUART: number;
	static readonly EASE_IN_OUT_QUART: number;
	static readonly EASE_IN_QUINT: number;
	static readonly EASE_OUT_QUINT: number;
	static readonly EASE_IN_OUT_QUINT: number;
	static create(from: number, to: number, length: number, easeType?: number): EaseTimer;
}

/**
 * Api-facing EntityType type constants
 */
declare class EntityType {
	protected constructor();
	static readonly UNDEFINED: number;
	static readonly STRUCTURE: number;
	static readonly RECT_STRUCTURE: number;
	static readonly LINE_SEGMENT_STRUCTURE: number;
	static readonly COLLISION_AREA: number;
	static readonly RECT_COLLISION_AREA: number;
	static readonly CHARACTER: number;
	static readonly PROJECTILE: number;
	static readonly ITEM: number;
	static readonly CUSTOM_GAME_OBJECT: number;
	static readonly HUD_ELEMENT: number;
	static readonly VFX: number;
	static readonly AI_GRAPH_NODE: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class TFrameTimer extends ASerializable {
	constructor(initDuration: number);
	active: boolean;
	completed: boolean;
	readonly duration: number;
	readonly elapsedFrames: number;
	tick(amount: number): void;
	finish(): void;
	reset(): void;
}

declare class FrameTimer extends TFrameTimer {
	constructor(initDuration: number);
	static create(duration: number): FrameTimer;
}

declare class GlowFilter extends Filter {
	color: number;
	alpha: number;
	radius: number;
	solid: boolean;
}

declare class HsbcColorFilter extends Filter {
	hue: number;
	saturation: number;
	brightness: number;
	contrast: number;
}

declare class IntMap {
	constructor();
	set(key: number, value: any): void;
	get(key: number): any;
	clear(): void;
	remove(key: number): boolean;
	exists(key: number): boolean;
	keys(): {hasNext: () => boolean, next: () => number};
}

declare class LineSegmentStructure extends Structure {
	getType(): number;
}

declare class Mask extends DisplayObject {
	constructor(width: number, height: number);
	scrollX: number;
	scrollY: number;
	addChild(displayObjectApi: DisplayObject): void;
	addChildAt(displayObjectApi: DisplayObject, index: number): void;
	removeChild(displayObjectApi: DisplayObject): void;
}

declare class MaskFilter extends Filter {
}

declare class Math {
	protected constructor();
	static NaN: number;
	static POSITIVE_INFINITY: number;
	static NEGATIVE_INFINITY: number;
	static PI: number;
	static floor: (v: number) => number;
	static ceil: (v: number) => number;
	static isNaN: (f: number) => boolean;
	static isFinite: (f: number) => boolean;
	static ffloor: (v: number) => number;
	static fround: (v: number) => number;
	static round: (v: number) => number;
	static pow: (v: number, exp: number) => number;
	static sqrt: (v: number) => number;
	static log: (v: number) => number;
	static max: (a: number, b: number) => number;
	static min: (a: number, b: number) => number;
	static sin: (v: number) => number;
	static cos: (v: number) => number;
	static tan: (v: number) => number;
	static asin: (v: number) => number;
	static acos: (v: number) => number;
	static atan: (v: number) => number;
	static atan2: (y: number, x: number) => number;
	static fastSin: (degrees: number) => number;
	static fastCos: (degrees: number) => number;
	static fastTan: (degrees: number) => number;
	static abs: (input: number) => number;
	static modulo: (number: number, modulo: number) => number;
	static forceBase360: (angle: number) => number;
	static getDistance(point1: Point, point2: Point): number;
	static getAngleBetween(center: Point, target: Point): number;
	static getAngleFromVelocity: (xVel: number, yVel: number) => number;
	static calculateXVelocity: (speed: number, angle: number) => number;
	static calculateYVelocity: (speed: number, angle: number) => number;
	static calculateSpeed: (x_speed: number, y_speed: number) => number;
	static toDegrees: (radians: number) => number;
	static toRadians: (degrees: number) => number;
	static flipAngleOverXAxis: (angle: number) => number;
	static flipAngleOverYAxis: (angle: number) => number;
	static angleDifference: (angleA: number, angleB: number) => number;
}

declare class NineSlice extends Drawable {
	tile: Tile;
	static create(nineSliceContent: string): NineSlice;
}

declare class OffscreenIndicator extends ApiObject {
	applyShaderEffects(drawable: Drawable): void;
	removeShaderEffects(drawable: Drawable): void;
	getSpriteContainer(): Container;
}

declare class Shader extends ASerializable {
	shared: boolean;
	priority: number;
	setPriority(value: number): void;
	kill(): void;
}

declare class PaletteSwapShader extends Shader {
	paletteMap: { [key: number]: number };
	static create(palette: { [key: number]: number }): PaletteSwapShader;
}

declare class Point extends TPoint {
	constructor(x: number, y?: number);
	dispose(): void;
	static create(x: number, y?: number): Point;
	static polar(len: number, angle: number, outPoint?: Point): Point;
	static interpolate(point1: Point, point2: Point, fraction: number): Point;
	/**
	 * Gets the interesection between two line segments (or null if no intersection can be found)
	 * @param a0 First point of line segment A
	 * @param a1 Second point of line segment A
	 * @param b0 First point of line segment B
	 * @param b1  Second point of line segment B
	 * @param out An existing point object to be used as a return value instead of allocating a new Point.
	 * @return Point The point at which the two line segments intersect (or null if there is no intersection)
	 */
	static lineSegmentsIntersect(a0: Point, a1: Point, b0: Point, b1: Point, out?: Point): Point;
}

declare class Random {
	protected constructor();
	static getValue: () => number;
	static getInt: (from: number, to: number) => number;
	static getFloat: (from: number, to: number) => number;
	static getChoice: (arr: any[]) => any;
	static getUnseededValue: () => number;
	static getUnseededInt: (from: number, to: number) => number;
	static getUnseededFloat: (from: number, to: number) => number;
	static getUnseededChoice: (arr: any[]) => any;
}

declare class RectCollisionArea extends CollisionArea {
	getRectangle(): Rectangle;
}

declare class RectStructure extends Structure {
	getType(): number;
}

declare class Resource {
	/**
	 * Given the specified content id, returns the full path to the content.
	 * @param contentId The content id whose path to expand
	 * @return The full path to the content id (or null if the path cannot be determined)
	 */
	getContent(contentId: string): string;
}

declare class RgbaColorShader extends Shader {
	color: number;
	redMultiplier: number;
	greenMultiplier: number;
	blueMultiplier: number;
	alphaMultiplier: number;
	redOffset: number;
	greenOffset: number;
	blueOffset: number;
	alphaOffset: number;
}

declare class RibbonTrail extends Drawable {
	points: TPoint[];
	movingRatio: number;
	alphaRatio: number;
	heightScale: number;
	updatePosition(x: number, y: number): void;
	start(x: number, y: number): void;
	stop(): void;
	getPalette(): { [key: number]: number };
	setPalette(value: { [key: number]: number }): { [key: number]: number };
}

declare class Score extends ApiObject {
	damageTakenTotal: number[];
	damageGivenTotal: number[];
	damageTakenThisLife: number[];
	damageGivenThisLife: number[];
	framesSinceDamageTaken: number;
	shieldCombo: number;
	falls: number;
	selfDestructs: number;
	timeDefeated: number;
	kos: number;
	kosThisLife: number;
	multiKills: number[];
}

declare class Sprite extends Drawable {
	hasAnimation(animation: string): boolean;
	goToFrameLabel(label: string): void;
	advance(): void;
	currentAnimation: string;
	currentFrame: number;
	totalFrames: number;
	getPalette(): { [key: number]: number };
	setPalette(value: { [key: number]: number }): { [key: number]: number };
	/**
	 * Generates a Sprite object from a given content id path.
	 * @param spriteContent The content id path of the sprite to be created.
	 * @return Sprite Instance of the sprite that was created.
	 */
	static create(spriteContent: string): Sprite;
	/**
	 * Batch method for generating numerous amounts of sprites in one call.
	 * @param	count The number of sprites to create
	 * @param	spriteContent The content id path of the Sprite to create
	 * @param	animationId The animation for the sprite to display
	 * @param	x X location of the Sprite
	 * @param	y Y location of the Spirte
	 * @param	container The container the Sprite should be added to
	 * @return An Array of all of the generated sprites
	 */
	static createBatch(count: number, spriteContent: string, animationId?: string, x?: number, y?: number, container?: Container): Sprite[];
}

declare class Stage extends ApiObject {
	resume(): void;
	pause(): void;
	hasAnimation(animation: string): boolean;
	playAnimation(name: string): void;
	playFrame(frame: number): void;
	playLabel(label: string): void;
	getCurrentFrame(): number;
	getTotalFrames(): number;
	getResource(): Resource;
	getBackgroundBehindContainer(): Container;
	getBackgroundStructuresContainer(): Container;
	getBackgroundShadowsContainer(): Container;
	getBackgroundEffectsContainer(): Container;
	getCharactersBackContainer(): Container;
	getCharactersContainer(): Container;
	getCharactersFrontContainer(): Container;
	getForegroundStructuresContainer(): Container;
	getForegroundShadowsContainer(): Container;
	getForegroundEffectsContainer(): Container;
	getForegroundFrontContainer(): Container;
	getDeathBounds(): RectCollisionArea;
	getCameraBounds(): RectCollisionArea;
	addEventListener(type: number, func: any, options?: {persistent?: boolean}): void;
	hasEventListener(type: number, func?: any): boolean;
	removeEventListener(type: number, func: any): void;
	/**
	 * Not currently implemented, will have no effect.
	 */
	updateLightboxStats(id: number, lightboxStats: {color?: number, intensity?: number, radius?: number, type?: number}): void;
	isDisposed(): boolean;
}

declare class StatsFile {
	getResource(): Resource;
}

declare class StringMap {
	constructor();
	set(key: string, value: any): void;
	get(key: string): any;
	clear(): void;
	remove(key: string): boolean;
	exists(key: string): boolean;
	keys(): {hasNext: () => boolean, next: () => string};
}

declare class StrokeFilter extends Filter {
	color: number;
	size: number;
}

declare class Tile extends ASerializable {
	dx: number;
	dy: number;
	width: number;
	height: number;
	x: number;
	y: number;
	center(): void;
	clone(): Tile;
	flipX(): void;
	flipY(): void;
	isDisposed(): boolean;
	scaleToSize(w: number, h: number): void;
	scrollDiscrete(x: number, y: number): void;
	setCenterRatio(x: number, y: number): void;
	setPosition(x: number, y: number): void;
	setSize(w: number, h: number): void;
	switchTexture(t: Tile): void;
	kill(): void;
	/**
	 * Generates a Tile object from a given content id path.
	 * @param spriteContent The content id path of the tile to be created.
	 * @return Tile Instance of the tile that was created.
	 */
	static create(tileContent: string): Tile;
}

declare class Vfx extends Entity {
	getType(): number;
	attachTo(object: Entity): void;
	unattachFromObject(): void;
	getSprite(): Sprite;
}

declare class Matrix {
	constructor(a: number, b?: number, c?: number, d?: number, tx?: number, ty?: number);
	a: number;
	b: number;
	c: number;
	d: number;
	tx: number;
	ty: number;
	init(a: number, b?: number, c?: number, d?: number, tx?: number, ty?: number): Matrix;
	copyFrom(matrix: any): any;
	identity(): void;
	scale(x: number, y: number): void;
	translate(x: number, y: number): void;
	rotate(angle: number): void;
	clone(): Matrix;
	equals(matrix: Matrix): boolean;
}

declare class CollisionBox {
	constructor(rectangle: Rectangle, type?: number);
	index: number;
	x: number;
	y: number;
	pivotX: number;
	pivotY: number;
	width: number;
	height: number;
	rotation: number;
	depth: number;
	centerX: number;
	centerY: number;
	name: string;
	type: number;
	rect: Rectangle;
	flippedRect: Rectangle;
	metadata: any;
	circular: boolean;
	equals(collisionBox: CollisionBox): boolean;
	clone(): CollisionBox;
	copyFrom(collisionBox: CollisionBox): void;
	/**
	 * Compare hit boxes from self and the provided hit box
	 */
	hitTest(theirCollisionBox: CollisionBox, selfLocation: TPoint, thatLocation: TPoint, selfScale: TPoint, thatScale: TPoint, selfRotation: number, thatRotation: number, selfPivot: TPoint, thatPivot: TPoint): Rectangle;
	static hitTestArray(arr1: CollisionBox[], arr2: CollisionBox[], selfLocation: TPoint, thatLocation: TPoint, selfScale: TPoint, thatScale: TPoint, selfRotation: number, thatRotation: number, selfPivot: TPoint, thatPivot: TPoint): CollisionResult[];
}

declare class AttackStrength {
	protected constructor();
	static readonly AUTO: number;
	static readonly LIGHT: number;
	static readonly MEDIUM: number;
	static readonly HEAVY: number;
	static readonly FATAL: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class AttackLimb {
	protected constructor();
	static readonly UNDEFINED: number;
	static readonly FIST: number;
	static readonly FOOT: number;
	static readonly HEAD: number;
	static readonly BODY: number;
	static readonly BATTERING: number;
	static readonly SWORD: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class BodyStatus {
	protected constructor();
	/**
	 * No effect.
	 */
	static readonly NONE: number;
	/**
	 * Prevents taking damage, flinching, and being grabbed. Foes will still receive selfHitstop.
	 */
	static readonly INVINCIBLE: number;
	/**
	 * Prevents taking damage and flinching. Object remains grabbable and foes will still receive selfHitstop.
	 */
	static readonly INVINCIBLE_GRABBABLE: number;
	/**
	 * Prevents interaction against foe hitboxes altogether.
	 */
	static readonly INTANGIBLE: number;
	/**
	 * Prevents flinching. Damage will still be received, and attacking foes will still receive selfHitstop.
	 */
	static readonly SUPER_ARMOR: number;
	/**
	 * Prevents damage and flinching up to the amount of damage specified by the bodyStatusStrength AnimationStats field. Attacking foes will still receive selfHitstop, and if the threshold is exceeded the full damage amount will be taken.
	 */
	static readonly DAMAGE_ARMOR: number;
	/**
	 * Prevents damage and flinching up to the amount of damage specified by the bodyStatusStrength AnimationStats field. Attacking foes will still receive selfHitstop, and if the threshold is exceeded the amount of damage received will be reduced by the amount specified by bodyStatusStrength.
	 */
	static readonly DAMAGE_RESISTANCE: number;
	/**
	 * Prevents damage and flinching up to the amount of knockback velocity specified by the bodyStatusStrength AnimationStats field. Attacking foes will still receive selfHitstop, and if the threshold is exceeded the full knockback velocity amount will be applied.
	 */
	static readonly LAUNCH_ARMOR: number;
	/**
	 * Prevents damage and flinching up to the amount of knockback velocity specified by the bodyStatusStrength AnimationStats field. Attacking foes will still receive selfHitstop, and if the threshold is exceeded the amount of knockback velocity received will be reduced by the amount specified by bodyStatusStrength.
	 */
	static readonly LAUNCH_RESISTANCE: number;
}

declare class AttackElement {
	protected constructor();
	static readonly NORMAL: number;
	static readonly WIND: number;
	static readonly FIRE: number;
	static readonly ELECTRIC: number;
	static readonly ICE: number;
	static readonly LAY: number;
	static readonly POISON: number;
	static readonly MAGIC: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class LandType {
	protected constructor();
	/**
	 * The engine will not handle landing at all, and you'll instead just float above the ground.
	 */
	static readonly NONE: number;
	/**
	 * The engine will perform landing-associated code but otherwise will not do anything.
	 */
	static readonly TOUCH: number;
	/**
	 * The engine will perform landing-associated code, and will attempt to send to the LAND state and change animations. Can be overridden.
	 */
	static readonly NORMAL: number;
	/**
	 * The engine will perform landing-associated code, will change animations to the provided landAnimation but will preserve state. Additionally, the frame the entity was on will be skipped to.
	 * As much as possible, this new animation is treated as though it were the original animation, so some stat values are ignored.
	 */
	static readonly LINK_FRAMES: number;
	/**
	 * The engine will do nothing at all, except for allow the user to override with their own behaviour.
	 */
	static readonly CUSTOM: number;
}

declare class LeaveGroundType {
	protected constructor();
	/**
	 * The engine will not do anything, the Character will remain in its current animation.
	 */
	static readonly NONE: number;
	/**
	 * The engine will cancel the animation and send the Character to the FALL state.
	 * If a leaveGroundAnimation is provided, the engine will play that animation instead of the default FALL state animation.
	 */
	static readonly TO_FALL: number;
	/**
	 * The engine will attempt to change animations to the provided leaveGroundAnimation, but will preserve the current state.
	 * If no leaveGroundAnimation is provided or it is invalid, then the animation will not be canceled.
	 */
	static readonly TRANSITION: number;
	/**
	 * The engine will attempt to change animations to the provided leaveGroundAnimation and will preserve the current state. Additionally, the frame the Character was on will be skipped to.
	 * As much as possible, this new animation is treated as though it were the original animation, so some stat values are ignored.
	 */
	static readonly LINK_FRAMES: number;
}

declare class PState {
	protected constructor();
	static readonly UNINITIALIZED: number;
	static readonly ACTIVE: number;
	static readonly DESTROYING: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class IState {
	protected constructor();
	static readonly UNINITIALIZED: number;
	static readonly ACTIVE: number;
	static readonly DESTROYING: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class SpecialAngle {
	protected constructor();
	/**
	 * Angle is dependent on velocity that the victim is sent at.
	 *
	 * The angle will either be exactly 0 degrees at low velocities, 45 at high velocities, or 45 if it hits an aerial foe.
	 * See: https://www.ssbwiki.com/File:Sakurai_angle_chart.png
	 */
	static DEFAULT: number;
	/**
	 * Angle is dependent on victim's grounded/aerial status.
	 *
	 * Grounded foes are sent at a 40 degree angle, aerial foes are sent at a 45 degree angle.
	 * See: https://www.rivalsofaether.com/workshop/hitbox-grid-indexes/
	 */
	static RIVALS: number;
	/**
	 * Angle is dependent on victim's damage.
	 *
	 * Increases .26 degrees per 1%, caps at 150% at a 40 degree angle.
	 * See: https://www.ssbwiki.com/File:Sakurai_angle_chart.png
	 */
	static DAMAGE: number;
	/**
	 * Angle is based off of the angle that the owner is currently moving.
	 *
	 * Unlike other autolink directions, the victim's launch speed will NOT be overridden by the angle (but flags will be forced with REVERSABLE_ANGLE), so make sure your baseknockback and knockbackgrowth are set!
	 */
	static AUTOLINK_WEAK: number;
	/**
	 * Angle is primarily based on owner velocity, adjusted by the victim's position relative to the autolink point (center of hitbox)
	 * Knockback is also based on owner velocity, but affected by victim position relative to the autolink point
	 * The attack's knockback growth and power can be used to fine-tune the amount of knockback:
	 * calculated_speed * (knockback_growth / 100) + power
	 * Note: Currently this angle type does not factor in baseScaleX/baseScaleY stats nor object rotation, so it will be innacurate if there is any scaling or rotation in place with the object involved.
	 */
	static AUTOLINK_STRONGER: number;
	/**
	 * Power and angle are based off of the owner's velocity and trajectory as well as the victim's position relative to the autolink point (center of the hitbox by default - override with hitboxStats.metadata.autolinkPoint).
	 *
	 * The victim's launch speed will be overridden to half of the owner's velocity. (Think angle 365 in Smash)
	 * Note: Currently this angle type does not factor in baseScaleX/baseScaleY stats nor object rotation, so it will be innacurate if there is any scaling or rotation in place with the object involved.
	 * WARNING: YOUR BASEKNOCKBACK AND KNOCKBACKGROWTH VALUES WILL BE IGNORED
	 */
	static AUTOLINK_STRONGEST: number;
	/**
	 * Angle is entirely random.
	 */
	static RANDOM: number;
	/**
	 * Angle is random, but cannot spike. (10-170)
	 */
	static RANDOM_UP: number;
	/**
	 * Based on params, calculates and returns a new angle as per the given SpecialAngle.
	 * If an autolink angle is calculated, also sets stats.reversible = false
	 * @param params
	 * @return Float
	 */
	static calculateAttackAngle(stats: HitboxStats, victim: GameObject, knockback: number, result: CollisionResult): number;
	/**
	 * Based on params, calculates a new knockback as per the given SpecialAngle. Not all SpecialAngle values modify knockback
	 * @return Float -1.0 if new knockback could not be calculated
	 */
	static calculateKnockback(stats: HitboxStats, victim: GameObject, result: CollisionResult): number;
}

declare class Flags {
	protected constructor();
	static allEnabled(sourceFlags: number, flagsToCheckFor: number): boolean;
	static anyEnabled(sourceFlags: number, flagsToCheckFor: number): boolean;
	static add(sourceFlags: number, flagsToAdd: number): number;
	static remove(sourceFlags: number, flagsToRemove: number): number;
	static set(sourceFlags: number, flagsToSet: number, value: boolean): number;
}

declare class CollisionBoxType {
	protected constructor();
	static ECB: number;
	static BODY: number;
	static MASTER: number;
	static NONE: number;
	static HURT: number;
	static HIT: number;
	static GRAB: number;
	static GRABHOLD: number;
	static SHIELD: number;
	static COUNTER: number;
	static LEDGEGRAB: number;
	static LEDGEHOLD: number;
	static REFLECT: number;
	static LIGHTBOX: number;
	static PIVOT: number;
	static ABSORB: number;
	static AUTOLINK: number;
	static CUSTOMA: number;
	static CUSTOMB: number;
	static CUSTOMC: number;
}

declare class LightboxType {
	protected constructor();
	static readonly POINT: number;
	static readonly AMBIENT: number;
	static readonly DIRECTIONAL: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class ParallaxMode {
	protected constructor();
	static readonly BOUNDS: number;
	static readonly PAN: number;
	static readonly DEPTH: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class AnimationEndType {
	protected constructor();
	/**
	 * Animation will stop on the final frame and take no further action
	 */
	static readonly NONE: number;
	/**
	 * Animation will repeat after it finishes
	 */
	static readonly LOOP: number;
	/**
	 * Animation will change depending on the values of AnimationStats.nextState and AnimationStats.nextAnimation
	 */
	static readonly AUTO: number;
}

/**
 * Wraps CState values so that equality can be checked directly
 */
declare class CharacterActions {
	protected constructor();
	static LEDGE_ATTACK: number;
	static CRASH_ATTACK: number;
	static JAB: number;
	static DASH_ATTACK: number;
	static TILT_FORWARD: number;
	static TILT_UP: number;
	static TILT_DOWN: number;
	static STRONG_FORWARD: number;
	static STRONG_UP: number;
	static STRONG_DOWN: number;
	static AERIAL_NEUTRAL: number;
	static AERIAL_BACK: number;
	static AERIAL_FORWARD: number;
	static AERIAL_UP: number;
	static AERIAL_DOWN: number;
	static SPECIAL_NEUTRAL: number;
	static SPECIAL_SIDE: number;
	static SPECIAL_UP: number;
	static SPECIAL_DOWN: number;
	static THROW_UP: number;
	static THROW_DOWN: number;
	static THROW_FORWARD: number;
	static THROW_BACK: number;
}

declare class JabResetType {
	protected constructor();
	/**
	 * The engine will handle jab reset behaviour based on knockback
	 */
	static readonly AUTO: number;
	/**
	 * The attack will always incur a jab reset, no matter how much knockback is generated
	 */
	static readonly ALWAYS: number;
	/**
	 * The attack will never incur a jab reset, no matter how little knockback is generated
	 */
	static readonly NEVER: number;
}

declare class BodyStatusColor {
	protected constructor();
	static readonly AUTO: number;
}

declare class BuryType {
	protected constructor();
	/**
	 * The attack will not induce a bury state.
	 */
	static readonly NONE: number;
	/**
	 * The attack will induce bury if the target is on the ground.
	 */
	static readonly BURY: number;
	/**
	 * The attack will induce bury if the target is on the ground, or will induce bury on their next ground touch while in hitstun.
	 */
	static readonly PLUNGE: number;
}

declare class StrongInputType {
	protected constructor();
	static readonly RIGHT_STRONG: number;
	static readonly DOWN_STRONG: number;
	static readonly LEFT_STRONG: number;
	static readonly UP_STRONG: number;
	static readonly NO_STRONG: number;
}

declare class ShakeWaveType {
	protected constructor();
	static readonly CUSTOM: number;
	static readonly RANDOM: number;
	static readonly FIXED: number;
	static readonly SINE: number;
}

declare class ShakeDecayType {
	protected constructor();
	static readonly CUSTOM: number;
	static readonly NONE: number;
	static readonly LINEAR: number;
	static readonly EASE_IN_QUAD: number;
	static readonly EASE_OUT_QUAD: number;
	static readonly EASE_IN_OUT_QUAD: number;
	static readonly EASE_IN_CUBIC: number;
	static readonly EASE_OUT_CUBIC: number;
	static readonly EASE_IN_OUT_CUBIC: number;
	static readonly EASE_IN_QUART: number;
	static readonly EASE_OUT_QUART: number;
	static readonly EASE_IN_OUT_QUART: number;
	static readonly EASE_IN_QUINT: number;
	static readonly EASE_OUT_QUINT: number;
	static readonly EASE_IN_OUT_QUINT: number;
}

declare class VfxLayer {
	protected constructor();
	static readonly BACKGROUND_BEHIND: string;
	static readonly BACKGROUND_STRUCTURES: string;
	static readonly BACKGROUND_SHADOWS: string;
	static readonly BACKGROUND_EFFECTS: string;
	static readonly CHARACTERS_BACK: string;
	static readonly CHARACTERS: string;
	static readonly CHARACTERS_FRONT: string;
	static readonly FOREGROUND_STRUCTURES: string;
	static readonly FOREGROUND_SHADOWS: string;
	static readonly FOREGROUND_EFFECTS: string;
	static readonly FOREGROUND_FRONT: string;
}

declare class VfxStats extends JSONClass {
	constructor(settings: {animation?: string, chain?: any, fadeOut?: boolean, flipWith?: boolean, forceVisible?: boolean, layer?: string, loop?: boolean, physics?: boolean, relativeWith?: boolean, resizeWith?: boolean, rotation?: number, scaleX?: number, scaleY?: number, shrink?: boolean, smoothing?: boolean, spriteContent?: string, timeout?: number, x?: number, y?: number});
	/**
	 * Content path for sprite entity of the Vfx
	 */
	spriteContent: string;
	/**
	 * Name of the Vfx animation to play
	 */
	animation: string;
	/**
	 * Absolute x position of the Vfx
	 */
	x: number;
	/**
	 * Absolute y position of the Vfx
	 */
	y: number;
	/**
	 * Horizontal scale of the Vfx
	 */
	scaleX: number;
	/**
	 * Vertical scale of the Vfx
	 */
	scaleY: number;
	/**
	 * Rotation of the Vfx in degrees
	 */
	rotation: number;
	/**
	 * Specifies the layer to render the Vfx on which can be any valid VfxLayer constant. Defaults to VfxLayer.CHARACTERS_FRONT.
	 */
	layer: string;
	/**
	 * How long to wait in frames before the Vfx should be removed. This also affects how long fade out and shrink should last (default: 0 = no timeout)
	 */
	timeout: number;
	/**
	 * Whether or not to enable smoothing on the Vfx Sprite
	 */
	smoothing: boolean;
	/**
	 * When true, The Vfx will be shown regardless of any optimization settings/configs
	 */
	forceVisible: boolean;
	/**
	 * When true, the Vfx animation will loop.
	 */
	loop: boolean;
	/**
	 * When true, the Vfx animation will fade out linearly from initial spawn to timeout.
	 */
	fadeOut: boolean;
	/**
	 * When true, the Vfx animation will scale down linearly from initial spawn to timeout.
	 */
	shrink: boolean;
	/**
	 * When true, the Vfx will respond to physics-related methods
	 */
	physics: boolean;
	/**
	 * Stats for a child Vfx to generate, inheriting all of the properties of its parent by default
	 */
	chain: any;
	/**
	 * Whether or not to force relative positioning of the effect against the GameObject's position
	 */
	relativeWith: boolean;
	/**
	 * Whether or not to scale the effect with the calling GameObject's current scale
	 */
	resizeWith: boolean;
	/**
	 * Whether or not to flip the effect based on the calling GameObject's horizontal scale
	 */
	flipWith: boolean;
}

declare class StructureStats extends JSONClass {
	constructor(settings: {accelFriction?: number, animationId?: string, conserveDownwardMomentum?: boolean, conserveHorizontalMomentum?: boolean, conserveUpwardMomentum?: boolean, decelFriction?: number, disableShadows?: boolean, disabled?: boolean, dropThrough?: boolean, foregroundAnimationId?: string, foregroundSpriteContent?: string, influenceX?: number, land?: boolean, leftLedge?: boolean, leftLedgeSize?: number, ricochet?: boolean, rightLedge?: boolean, rightLedgeSize?: number, spriteContent?: string, startX?: number, startY?: number, structureType?: number});
	/**
	 * Starting X position of the structure
	 */
	startX: number;
	/**
	 * Starting Y position of the structure
	 */
	startY: number;
	/**
	 * When true, this CollisionArea instance should become inactive and all hitTests should return false.
	 */
	disabled: boolean;
	/**
	 * The content id path of the sprite to load for this structure
	 */
	spriteContent: string;
	/**
	 * Content id path of the foreground sprite to load for this structure
	 */
	foregroundSpriteContent: string;
	/**
	 * The id of the animation to use for this structure
	 */
	animationId: string;
	/**
	 * The id of the foreground sprite to use for this structure
	 */
	foregroundAnimationId: string;
	/**
	 * The type of collision behavior to use on this structure
	 */
	structureType: number;
	/**
	 * When false, it will not be possible for game objects to bounce off this object
	 */
	ricochet: boolean;
	/**
	 * When false, the player should be disallowed from falling through the structure via any means. Set to true to permit structure drop-through capability for objects that utilize it.
	 */
	dropThrough: boolean;
	/**
	 * When enabled, left ledge grabs will be enabled on this structure (StructureType.FLOOR only).
	 */
	leftLedge: boolean;
	/**
	 * When enabled, right ledge grabs will be enabled on this structure (StructureType.FLOOR only).
	 */
	rightLedge: boolean;
	/**
	 * Determines the length of this structure's left ledges (StructureType.FLOOR only).
	 */
	leftLedgeSize: number;
	/**
	 * Determines the length of this structure's right ledges (StructureType.FLOOR only).
	 */
	rightLedgeSize: number;
	/**
	 * When true, objects can land on the structure. When false, the structure will still prevent objects from passing through however their structureCollision component will never register an object as "landed". (StructureType.FLOOR only).
	 */
	land: boolean;
	/**
	 * When true, shadows should be disabled from rendering on this structure. This is not implemented by the game engine, so you are expected to use it to your needs.
	 */
	disableShadows: boolean;
}

declare class TumbleType {
	protected constructor();
	/**
	 * The engine will handle tumble behaviour based on knockback
	 */
	static readonly AUTO: number;
	/**
	 * The attack will always incur tumble, no matter how little knockback is generated
	 */
	static readonly ALWAYS: number;
	/**
	 * The attack will never incur tumble, no matter how much knockback is generated
	 */
	static readonly NEVER: number;
}

/**
 * Governs behaviour of the entity when GRAB is pressed midair
 */
declare class GrabAirType {
	protected constructor();
	/**
	 * The engine will do nothing, and essentially ignore the input
	 */
	static readonly NONE: number;
	/**
	 * The engine will perform an aerial attack, also taking into account the input direction
	 */
	static readonly AERIAL: number;
	/**
	 * The engine will jump to the grab_air animation, if it exists. If no animation is found, acts like NONE
	 */
	static readonly GRAB: number;
}

/**
 * EntityEvent class represents events that occur within an Entity
 */
declare class EntityEvent extends CustomEvent {
	readonly data: {fromState?: number, match?: Match, other?: ApiObject, self?: Entity, structureType?: number, toState?: number};
	static readonly STATE_CHANGE: number;
	static readonly COLLIDE_WALL: number;
	static readonly COLLIDE_CEILING: number;
	static readonly COLLIDE_FLOOR: number;
	static readonly COLLIDE_STRUCTURE: number;
	static readonly DISPOSE: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

/**
 * GameObjectEvent class represents events that occur within a GameObject
 */
declare class GameObjectEvent extends CustomEvent {
	readonly data: {damage?: number, foe?: GameObject, fromState?: number, hitboxStats?: HitboxStats, hitstun?: number, match?: Match, other?: ApiObject, self?: Entity, state?: number, structureType?: number, toState?: number};
	static readonly HITBOX_CONNECTED: number;
	static readonly HIT_RECEIVED: number;
	static readonly HIT_DEALT: number;
	static readonly DAMAGE_UPDATED: number;
	static readonly COUNTER: number;
	static readonly GRAB_DEALT: number;
	static readonly GRAB_RECEIVED: number;
	static readonly REFLECTBOX_CONNECTED: number;
	static readonly REFLECTED: number;
	static readonly ABSORBBOX_CONNECTED: number;
	static readonly ABSORBED: number;
	static readonly PROJECTILE_CREATED: number;
	static readonly LAND: number;
	static readonly ENTER_HITSTUN: number;
	static readonly EXIT_HITSTUN: number;
	static readonly ENTER_HITSTOP: number;
	static readonly EXIT_HITSTOP: number;
	static readonly SPIKE_RECEIVED: number;
	static readonly LINK_FRAMES: number;
	static readonly LEFT_GROUND: number;
	static readonly SHIELDBOX_CONNECTED: number;
	static readonly SHIELD_HIT_RECEIVED: number;
	static readonly SHIELD_HIT_DEALT: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

/**
 * CharacterEvent class represents events that occur within a Character
 */
declare class CharacterEvent extends CustomEvent {
	readonly data: {damage?: number, direction?: number, foe?: GameObject, fromState?: number, hitboxStats?: HitboxStats, hitstun?: number, match?: Match, other?: ApiObject, self?: Entity, state?: number, structureType?: number, toState?: number};
	static readonly LEDGE_GRAB: number;
	static readonly KNOCK_OUT: number;
	static readonly ATTACK_START: number;
	static readonly ATTACK_END: number;
	static readonly WALL_BOUNCE: number;
	static readonly FLOOR_BOUNCE: number;
	static readonly CEILING_BOUNCE: number;
	static readonly OFFSCREEN: number;
	static readonly GRAB_CLANK: number;
	static readonly JUMP_CANCEL: number;
	static readonly RESPAWN: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

/**
 * Event that represents changes in a Control instance.
 */
declare class MatchEvent extends CustomEvent {
	readonly data: {match?: Match};
	static readonly TICK_START: number;
	static readonly TICK_END: number;
	static readonly INTROS_STARTED: number;
	static readonly MATCH_STARTED: number;
	static readonly MATCH_BEFORE_END_GRAPHIC_SHOWN: number;
	static readonly MATCH_END_GRAPHIC_SHOWN: number;
	static readonly MATCH_ENDED: number;
	static readonly MATCH_PAUSED: number;
	static readonly MATCH_UNPAUSED: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

/**
 * Event that represents changes in a Control instance.
 */
declare class GameTimerEvent extends CustomEvent {
	readonly data: {match?: Match, time?: number};
	static readonly SECOND_ELAPSED: number;
	static readonly TIMER_COMPLETE: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

/**
 * StructureEvent class represents events that occur on a Structure object
 */
declare class StructureEvent extends CustomEvent {
	readonly data: {collisionPoint?: TPoint, entity?: Entity, fromState?: number, match?: Match, other?: ApiObject, self?: Entity, structureType?: number, toState?: number};
	static readonly COLLIDE_ENTITY: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

declare class LobbyEvent extends CustomEvent {
	readonly data: {data?: any, desyncFrame?: number, lobbies?: {capacity: number, hasPassword: boolean, kind: number, matchmakingGroup: number, members: number, metadata?: any, name: string, owner: string, protocol: number, region: number, regionRestricted: boolean, score: number, sessionData: {matchData: {matchConfig: {damageMode?: boolean, damageRatio?: number, entrances?: boolean, hazards?: boolean, lives?: number, matchRules?: {contentId: string, namespace: string, resourceId: string}[], metadata?: any, music?: {contentId: string, namespace: string, resourceId: string}, netcodeInputBuffer?: number, netcodeType?: number, pauseMenuId?: string, playerIDs?: boolean, preloadMediaMap?: any, randSeed?: string, sizeRatio?: number, specialModes?: number, stage?: {contentId: string, namespace: string, resourceId: string}, startDamage?: number, teamAttack?: boolean, teams?: boolean, time?: number}, playerConfigs: {attackRatio?: number, character?: {contentId: string, namespace: string, resourceId: string}, clientUid?: string, costume?: number, cpu?: boolean, damageMode?: boolean, damageRatio?: number, isRandom?: boolean, level?: number, lives?: number, metadata?: any, name?: string, playerBorder?: PlayerBorder, port?: number, startDamage?: number, team?: number}[]}, metadata: any, mode: {contentId: string, namespace: string, resourceId: string}}, uid: string, version: string}[], lobby?: {capacity: number, hasPassword: boolean, kind: number, matchmakingGroup: number, members: number, metadata?: any, name: string, owner: string, protocol: number, region: number, regionRestricted: boolean, score: number, sessionData: {matchData: {matchConfig: {damageMode?: boolean, damageRatio?: number, entrances?: boolean, hazards?: boolean, lives?: number, matchRules?: {contentId: string, namespace: string, resourceId: string}[], metadata?: any, music?: {contentId: string, namespace: string, resourceId: string}, netcodeInputBuffer?: number, netcodeType?: number, pauseMenuId?: string, playerIDs?: boolean, preloadMediaMap?: any, randSeed?: string, sizeRatio?: number, specialModes?: number, stage?: {contentId: string, namespace: string, resourceId: string}, startDamage?: number, teamAttack?: boolean, teams?: boolean, time?: number}, playerConfigs: {attackRatio?: number, character?: {contentId: string, namespace: string, resourceId: string}, clientUid?: string, costume?: number, cpu?: boolean, damageMode?: boolean, damageRatio?: number, isRandom?: boolean, level?: number, lives?: number, metadata?: any, name?: string, playerBorder?: PlayerBorder, port?: number, startDamage?: number, team?: number}[]}, metadata: any, mode: {contentId: string, namespace: string, resourceId: string}}, uid: string, version: string}, lobbyMatchData?: {matchConfig: {damageMode?: boolean, damageRatio?: number, entrances?: boolean, hazards?: boolean, lives?: number, matchRules?: {contentId: string, namespace: string, resourceId: string}[], metadata?: any, music?: {contentId: string, namespace: string, resourceId: string}, netcodeInputBuffer?: number, netcodeType?: number, pauseMenuId?: string, playerIDs?: boolean, preloadMediaMap?: any, randSeed?: string, sizeRatio?: number, specialModes?: number, stage?: {contentId: string, namespace: string, resourceId: string}, startDamage?: number, teamAttack?: boolean, teams?: boolean, time?: number}, playerConfigs: {attackRatio?: number, character?: {contentId: string, namespace: string, resourceId: string}, clientUid?: string, costume?: number, cpu?: boolean, damageMode?: boolean, damageRatio?: number, isRandom?: boolean, level?: number, lives?: number, metadata?: any, name?: string, playerBorder?: PlayerBorder, port?: number, startDamage?: number, team?: number}[]}, message?: string, ping?: number, pingMax?: number, pingMin?: number, playerConnectionInfo?: any, playerConnectionInfos?: any[], uid?: string};
	static readonly CONNECT: number;
	static readonly DISCONNECT: number;
	static readonly LOGIN: number;
	static readonly LOBBY_CREATED: number;
	static readonly LOBBY_JOIN_REQUEST: number;
	static readonly LOBBY_JOINED: number;
	static readonly LOBBY_LIST: number;
	static readonly LOBBY_DATA_UPDATED: number;
	static readonly MATCHMAKING_STARTED: number;
	static readonly MATCHMAKING_STOPPED: number;
	static readonly MATCHMAKING_MATCH_FOUND: number;
	static readonly MATCHMAKING_SEARCH_EXPAND: number;
	static readonly MODE_START: number;
	static readonly MODE_END: number;
	static readonly LOCK_LOBBY: number;
	static readonly UNLOCK_LOBBY: number;
	static readonly INVITE_RECEIVED: number;
	static readonly LEAVE_LOBBY: number;
	static readonly MATCH_START: number;
	static readonly MATCH_READY_STATUS: number;
	static readonly MATCH_END: number;
	static readonly MATCH_FINISHED: number;
	static readonly DATA: number;
	static readonly NOTIFY: number;
	static readonly PLAYER_JOINED: number;
	static readonly PLAYER_LEFT: number;
	static readonly ERROR_DESYNC: number;
	static readonly ERROR_OFFLINE: number;
	static readonly ERROR_CONNECT: number;
	static readonly ERROR_CONNECT_GAME: number;
	static readonly ERROR_LOGIN: number;
	static readonly ERROR_CREATE_LOBBY: number;
	static readonly ERROR_REQUEST_TO_JOIN_LOBBY: number;
	static readonly ERROR_JOIN_LOBBY: number;
	static readonly ERROR_LOBBY_DATA: number;
	static readonly ERROR_LOCK_LOBBY: number;
	static readonly ERROR_UNLOCK_LOBBY: number;
	static readonly ERROR_LEAVE_LOBBY: number;
	static readonly ERROR_MATCH_READY_STATUS: number;
	static readonly ERROR_LOBBY_LIST: number;
	static readonly PING: number;
	static readonly PING_PEER: number;
	static readonly PING_PEER_ALL: number;
	static readonly SLOW_PEER: number;
	static readonly ERROR_PING: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

/**
 * CameraEvent class represents events that are specific to the game camera
 */
declare class CameraEvent extends CustomEvent {
	readonly data: {camera?: Camera, match?: any, tickable?: any};
	static readonly UPDATED: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

/**
 * Event that represents changes in a Control instance.
 */
declare class ScoreEvent extends CustomEvent {
	readonly data: {foe?: GameObject, self?: Entity, value?: number};
	static readonly FALL: number;
	static readonly KO_BLAST: number;
	static readonly COMBO: number;
	static readonly SHIELDED: number;
	static readonly PARRY: number;
	static readonly RECOVERY: number;
	static readonly SPIKE: number;
	static readonly FULLY_CHARGED_STRONG: number;
	/**
	 * Translates constant to a user-readable string.
	 */
	static constToString(value: number): string;
}

/**
 * Helper class for managing controls inputs
 */
declare class ControlsObject extends ASerializable {
	constructor();
	/**
	 * Current state of button inputs represented by a 32-bit integer
	 */
	buttons: number;
	/**
	 * Current state of input flags represented by a 32-bit integer
	 */
	flags: number;
	/**
	 * Angle of the left stick calculated using leftStickX and leftStickY
	 */
	leftStickAngle: number;
	/**
	 * Angle of the right stick calculated using leftStickX and leftStickY
	 */
	rightStickAngle: number;
	leftStickAxes: number;
	leftStickX: number;
	leftStickY: number;
	rightStickAxes: number;
	rightStickX: number;
	rightStickY: number;
	hasRightStickAttackFlag(): boolean;
	hasRightStickSpecialFlag(): boolean;
	rightStickPressed(): boolean;
	analogDashActive(): boolean;
	analogWalkActive(): boolean;
	digitalDashActive(): boolean;
	digitalWalkActive(): boolean;
	UP: boolean;
	DOWN: boolean;
	LEFT: boolean;
	RIGHT: boolean;
	ATTACK: boolean;
	SPECIAL: boolean;
	ACTION: boolean;
	JUMP: boolean;
	JUMP_ANY: boolean;
	SHIELD: boolean;
	SHIELD1: boolean;
	SHIELD2: boolean;
	GRAB: boolean;
	EMOTE: boolean;
	PAUSE: boolean;
	RIGHT_STICK_UP: boolean;
	RIGHT_STICK_DOWN: boolean;
	RIGHT_STICK_LEFT: boolean;
	RIGHT_STICK_RIGHT: boolean;
	DASH: boolean;
	DROP_THROUGH: boolean;
	SHORT_HOP: boolean;
	SHIELD_AIR: boolean;
	TILT: boolean;
	STRONG: boolean;
	TAP_JUMP: boolean;
	CROUCH: boolean;
	FULL_HOP: boolean;
	reset(): void;
	/**
	 * Copies the controls values from another ControlsObject instance
	 * @param	controlsObject The ControlsObject instance to copy controls data from
	 */
	copyFrom(controlsObject: ControlsObject): void;
	clone(): ControlsObject;
	/**
	 * Returns the angle of the left stick or right sticks, rounded to the nearest 45 degree angle
	 * @param	rightStick Pass as true to use the right stick for the angle calculation. Otherwise the left stick is used.
	 * @return Returns the angle the left or right stick rounded to the nearest 45 degrees
	 */
	getAngle(rightStick: boolean): number;
	syncStickAngles(): void;
	/**
	 * Ensure the directional buttons correspond with any stick angle
	 */
	syncStickButtons(): void;
	/**
	 * Returns a user readable string of current inputs
	 * @return String representing all inputs that are currently held
	 */
	toString(): string;
	/**
	 * Figures out which buttons were pressed VS held provided the previous and current control bits
	 * @param	previousControls Bits for the previous buttons
	 * @param	currentControls Bits for the current buttons
	 */
	static determinePressedControls(previousControls: number, currentControls: number): number;
}

declare class CollisionResult {
	constructor(hitboxA: CollisionBox, hitboxB: CollisionBox, overlapBox: CollisionBox);
	/**
	 * The source box used in the collision test that is having its collisions tested against another object.
	 */
	boxA: CollisionBox;
	/**
	 * The target box used in the collision test against boxA.
	 */
	boxB: CollisionBox;
	/**
	 * A new CollisionBox describing the rough overlapping area of the collision.
	 */
	overlapBox: CollisionBox;
}

declare class DisplayMode {
	protected constructor();
	/**
	 * Fully windowed mode.
	 */
	static readonly Windowed: number;
	/**
	 * Windowed with borders hidden.
	 */
	static readonly Borderless: number;
	/**
	 * Full screen mode.
	 */
	static readonly Fullscreen: number;
}

declare class CollisionAreaStats extends JSONClass {
	constructor(settings: {disabled?: boolean, startX?: number, startY?: number});
	/**
	 * Starting X position of the collision area.
	 */
	startX: number;
	/**
	 * Starting Y position of the collision area.
	 */
	startY: number;
	/**
	 * When true, this CollisionArea instance should become inactive and all hitTests should return false.
	 */
	disabled: boolean;
}

declare class StageShadowLayerStats extends JSONClass {
	constructor(settings: {color?: number, foreground?: boolean, id?: string, maskAnimationId?: string, maskSpriteContent?: string});
	/**
	 * Identifying string for this shadow layer for targeting with a shadow light source.
	 */
	id: string;
	/**
	 * The content id path of the mask sprite to load for this stage shadow layer
	 */
	maskSpriteContent: string;
	/**
	 * The name of the animation that contains the mask for this shadow layer
	 */
	maskAnimationId: string;
	/**
	 * Specifies the color of shadows for this layer
	 */
	color: number;
	/**
	 * Specifies whether this shadow layer should be placed directly adjacent to to the foreground layer or background layer.
	 */
	foreground: boolean;
}

declare class StageStats extends JSONClass {
	constructor(settings: {ambientColor?: number, animationId?: string, camera?: {backgrounds?: {animationId?: string, antiAliasing?: boolean, customContainer?: any, depth?: number, foreground?: boolean, horizontalPanLock?: boolean, horizontalScroll?: boolean, loopHeight?: number, loopWidth?: number, mode?: string, offsetX?: number, offsetY?: number, originalBGHeight?: number, originalBGWidth?: number, scaleMultiplier?: number, spriteContent?: string, verticalPanLock?: boolean, verticalScroll?: boolean, xPanMultiplier?: number, yPanMultiplier?: number}[], boundary?: Rectangle, camEaseRate?: number, camMoveThreshold?: number, camZoomRate?: number, freeCamSpeed?: number, initialHeight?: number, initialWidth?: number, minZoomHeight?: number, startX?: number, startY?: number, zoomX?: number, zoomY?: number}, shadowLayers?: {color?: number, foreground?: boolean, id?: string, maskAnimationId?: string, maskSpriteContent?: string}[], spriteContent?: string});
	/**
	 * The content id path of the sprite to load for this stage
	 */
	spriteContent: string;
	/**
	 * The name of the animation that contains the stage's main contents
	 */
	animationId: string;
	/**
	 * Shadow layers for the stage
	 */
	shadowLayers: {color?: number, foreground?: boolean, id?: string, maskAnimationId?: string, maskSpriteContent?: string}[];
	/**
	 * Camera settings for the stage
	 */
	camera: {backgrounds?: {animationId?: string, antiAliasing?: boolean, customContainer?: any, depth?: number, foreground?: boolean, horizontalPanLock?: boolean, horizontalScroll?: boolean, loopHeight?: number, loopWidth?: number, mode?: string, offsetX?: number, offsetY?: number, originalBGHeight?: number, originalBGWidth?: number, scaleMultiplier?: number, spriteContent?: string, verticalPanLock?: boolean, verticalScroll?: boolean, xPanMultiplier?: number, yPanMultiplier?: number}[], boundary?: Rectangle, camEaseRate?: number, camMoveThreshold?: number, camZoomRate?: number, freeCamSpeed?: number, initialHeight?: number, initialWidth?: number, minZoomHeight?: number, startX?: number, startY?: number, zoomX?: number, zoomY?: number};
	/**
	 * Specifies the color that should be added to non-stage elements
	 */
	ambientColor: number;
}

/**
 * Aggregates a group of StatusEffectObjects into a collective status effect.
 */
declare class StatusEffect extends ASerializable {
	constructor();
	values: {id: string, options?: {fields?: {frameTimer?: TFrameTimer}, metadata?: any, params?: {interval?: number}, tag?: string}, value: number}[];
	getSum(): number;
	getProduct(): number;
}

declare class BodyStatusTimer extends TFrameTimer {
	constructor(status: number, duration: number);
	readonly bodyStatus: number;
}
declare interface IApiObject {
	/**
	 * Generic exports object accessible via the Api's global scope. Arbitrary variables and functions can be attached to it, but note that this object will not be automatically serialized for rollback.
	 */
	exports: any;
	isDisposed(): boolean;
	/**
	 * Allocates a serializable integer
	 * @param	value Initial value of integer
	 * @return Returns the serializable wrapper for the integer
	 */
	makeInt(value: number): ApiVarInt;
	/**
	 * Allocates a serializable float
	 * @param	value Initial value of float
	 * @return Returns the serializable wrapper for the float
	 */
	makeFloat(value: number): ApiVarFloat;
	/**
	 * Allocates a serializable boolean
	 * @param	value Initial value of boolean
	 * @return Returns the serializable wrapper for the float
	 */
	makeBool(value: boolean): ApiVarBool;
	/**
	 * Allocates a serializable string. Maximum limit of serializable strings is currently 4 per object.
	 * @param	value Initial value of string
	 * @return Returns the serializable wrapper for the string
	 */
	makeString(value: string): ApiVarString;
	/**
	 * Allocates a serializable object. Unlike serializable primitives, this only serializes the pointer to the objects you set it to rather than literally serializing the data within the object. When the historical state of your ApiObject is popped, the reference to the object that existed at the time the history was last pushed will be restored. ApiObjects will be serialized by the engine, however for anonymous structures you must manage their internal history yourself.
	 * @param	value Object to store a reference to
	 * @return Returns the serializable wrapper for the object
	 */
	makeObject(value: any): ApiVarObject;
	/**
	 * Allocates an Array of objects references. Note that this data type only serializes the pointer to the objects you set it to rather than literally serializing the data within the object. When the historical state of your ApiVarerenceArray is popped, the reference to the Array that existed at the time the history was last pushed will be restored.
	 * @param	value Object reference array to serialize
	 * @return Returns the serializable wrapper for the object
	 */
	makeArray(value: any[]): ApiVarArray;
	/**
	 * Allocates a rollback-friendly FrameTimer instance that will be automatically destroyed when this object is disposed of.
	 */
	makeFrameTimer(initDuration: number): FrameTimer;
	/**
	 * Allocates a rollback-friendly EaseTimer instance that will be automatically destroyed when this object is disposed of.
	 */
	makeEaseTimer(from: number, to: number, length: number, easeType?: number): EaseTimer;
	/**
	 * Allocates a rollback-friendly Point instance that will be automatically destroyed when this object is disposed of.
	 */
	makePoint(x: number, y?: number): Point;
}
